# 网络游戏架构设计

## 第一节 代码结构

### 项目代码结构需要满足的需求

#### 热更新

需要把Unity的MonoBehaviour等等这些和Unity交互较深的脚本进行分离

至少有一个热更新的程序集

#### 数据跟方法分离，热重载

##### 热重载

​	热重载只是数据跟方法分离后得到的好处

​	热重载便于改bug，节省重现环节。

##### 数据跟方法分离

​	在C语言中叫做`data + function`的设计。数据就是定义数据结构，方法则是面向过程的方法。

​	相比于面向对象而已没有类与类之间的关联，只有方法和方法的关联，便于重构。

#### 逻辑跟表现分离

数据是同步的，而表现可能是异步的情况。在表现过程中可能会有一些资源加载的操作，在这个过程中逻辑发生了变化，表现也需要发生变化。

预表现。表现层可能提前做出一些表现比如一些战斗前摇，但是对逻辑层没有什么影响。等逻辑层同步了命中逻辑后，再播放命中的表现。

在MMO的切换场景中，服务器通知场景切换后，客户端逻辑层加载数据，表现层则在数据加载完成后开始异步加载场景。服务器再通知单位模型的数据后，客户端逻辑层整理数据后，表现成开始异步加载单位模型。

帧同步。帧同步两端的逻辑层的逻辑是一样的。而状态同步逻辑在服务端，两端的逻辑层实际上也是一样的。区别只在于一个是客户端计算一个是服务端计算。 帧同步如果把逻辑层看做是一个服务端，看起来就像是逻辑层在给表现层发消息。逻辑是离散的，表现是要做插值的。

#### ECS数据驱动

数据变化是通过事件通知的。逻辑和表现监听事件产生变化。

### ET版本变更

#### 1.0

客户端

- Hoxfix 热更层
- Main 主工程

服务端

- Hoxfix 纯逻辑
- Main 纯数据

#### 中间版本

客户端 

asmdef功能，多个程序集提升编译速度

- Hoxfix	热更层
- Loader 游戏入口，可放Unity脚本
- Core 框架核心
- ThirdParty 第三方库

服务端

- Hoxfix
- Model
- Loader
- Core
- ThirdParty

#### 热重载需求

客户端

- Hoxfix 热更层的逻辑层  
  - 纯逻辑改变时不用关闭游戏，直接重载这个程序集
- Model 热更层的数据层
- Loader 游戏入口，可放Unity脚本
- Core 框架核心
- ThirdParty 第三方库

#### 另一种划分

- HoxfixView 表现层
- Hoxfix 逻辑层 抛事件通知表现层
- Loader
- ThridParty
- Core

#### 结合前面两个版本

##### 客户端

- HoxfixView 表现层的方法
- ModelView 表现层数据结构
- Hofix 逻辑层方法
- Model 逻辑层数据
- Loader
- Core
- ThridParty

前四个程序集编译在一起做热更新。HofixView和Hofix编译在一起做热重载。

并且逻辑和表现分离

##### Robot

- Hofix 逻辑层方法
- Model 逻辑层数据
- Loader
- Core
- ThridParty

去掉客户端的表现层，就是机器人的程序集了。

Hofix和Model共用客户端的程序集。

## 第二节 All In One

### 各类服务器进程合并

![微信图片_20230308124513](网络游戏架构设计-熊猫.assets/微信图片_20230308124513.png)

很多多进程的设计，都把一个服务整理成一个exe。多个服务就有多个exe，代码可能是高度相似的，或者基本一样的。只是启动时环境变量不同。合并成一个exe并设置环境变量。

- 发布部署简单、配置资源方便、多种服务共用进程。
- 结构调整容易，比如两种或多种服务要合并，拆分
  - 多个exe会有多个进程，当其中一部分逻辑压力过大时（比如一个中心服有好友和组队功能，好友功能压力过大时 ）不好拆分，需要再拆成多个exe。
  - 无限增加app类型，千古风流有几十种SceneType
  - 根据配置需要什么服务，就配置什么类型。多个服务配置在一个进程内。

### 后端和机器人合并

![微信图片_20230308124518](网络游戏架构设计-熊猫.assets/微信图片_20230308124518-1678250733684.jpg)

机器人和服务器的代码基本一样。也引用了大部分的后端代码。还引用了客户端的逻辑代码。代码引用很乱。

机器人要单独起一个exe很不方便，跑测试需要起两个进程。

#### server和机器人合并带来的问题

- 代码类重名
  - 合并后分别引用了客户端和服务端的代码。两端代码的类名重名（item、buff）。
  - 用命名空间隔离解决重名冲突，带来的好处只需要检查目录下的命名空间就能保证不会调用到错误的代码。
  - ET.Server、ET.Client
- 事件订阅怎么区分前后端
  -  有些工具类，或数值组件这种两端共用的代码就不用隔离。ET
  - 比如单位组件，前后端都有抛出的事件很难做区分。需要区分订阅。
  - 通过场景类型做区分SceneType
- 配置文件结构不同怎么共享
  - 问题也不大，大不了两端配置都存在。

机器人在写组队逻辑时很有用。

### 前端跟后端合并

![微信图片_20230308123835](网络游戏架构设计-熊猫.assets/微信图片_20230308123835.jpg)

#### 不需要单独起服务端，前后端代码共享更方便

不需要单独启动服务器，unity一启动就启动前后端代码。

前后端代码的共享，前端可以包含一个服务器，后端可以包含前端的逻辑做个机器人。

#### 后端可以更方便做Unity可视化工具，可视化树ENABLE_VIEW

后端如果是命令行程序，做数据可视化很困难。

写后端就像写前端一样简单，比如写个行为树，后端可以直接调试，前端可以直接拿到后端数据。

ET7加上ENABLE_VIEW宏开启可视化树

#### 更方便做插件机制

用unity的导入导出做插件机制。

#### 各种游戏代码合并的需求分析

##### 竞技游戏

比如守望先锋，用的状态帧同步。本地先预测下一帧行为，服务器同步下来如果结果不符合则进行回滚。那么两端肯定有相同代码，否则产生结果肯定是不一致的。

##### MMO游戏、MOBA游戏

模拟机器人的需求，充当普通玩家。

机器人压测需求。

##### 状态同步

客户端预测和服务器权威数据跑的代码基本一致。

##### 帧同步

逻辑都在客户端，但是在结算结果的时候数据不权威。后期帧同步，很多是依靠服务器也跑一份逻辑，根据跑出来的结果判定结算。也是防作弊很重要的内容。

### 前端和后端合并的细节问题

#### 怎么区分编译前端代码跟后端代码，还有双端编译

搞一个编译工具，按照需求选择编译

#### 配置要区分前端跟后端，以及双端，configpatial的处理

有些配置不需要双端都知道的，比如前端的特效，或后端比较权威计算的数值。

这就需要导出三份配置。C、CS、S

config patial就是把配置反序列化成需要的类对象的工具

config patial不能共享，需要写三份。

消息要区分前后端，以及双端。

#### 总结

![微信图片_20230308123804](网络游戏架构设计-熊猫.assets/微信图片_20230308123804-1678250496566.jpg)

把服务器逻辑代码也写在客户端程序集内，直接引用。

![微信图片_20230308005444](网络游戏架构设计-熊猫.assets/微信图片_20230308005444.jpg)

## 第三节 单间管理器

### 为什么需要单间管理器？

#### 统一管理单间类。单间类的问题？

单间类生命周期的问题，创建了什么时候释放的问题。

内存随着生命周期清理的问题。

#### 统一管理基础库，灵活引入基础库

#### 消除静态字段

`static Dictionary`这种静态变量，生命周期清理的问题。

#### Unity domain模式

domain模式为了提升性能不清理静态字段，需要自己清理。

#### 为什么不用组件？

组件本身需要一些额外的东西，比如创建的时候需要对象池。对象池又是谁管理。就可以使用单间管理器创建对象池。

#### 为什么用Game.AddSingleton 创建单间

`Game.AddSingleton<TimeInfo>();`

##### 代码可读性，明确知道单间初始化的地方。

如果都是`Instance`很难找到哪里是初始化的地方。

##### 明确知道初始化顺序，方便调整

##### 好释放，相反的顺序释放

明确知道了初始化顺序，能更明确释放的顺序。

```c#
public interface ISingleton: IDisposable
{
    void Register();
    void Destroy();
    bool IsDisposed();
}
public class Singleton<T>: ISingleton where T: Singleton<T>, new(){

}
```

##### 通过接口创建生命周期

`ISingletonAwake` 、`ISingletonUpdate` 、`ISingletonLateUpdate`

`AddSingleton`时判断是否有生命周期接口，如果有添加对应生命周期。

```c#
public static void AddSingleton(ISingleton singleton)
{
    Type singletonType = singleton.GetType();
    if (singletonTypes.ContainsKey(singletonType))
    {
        throw new Exception($"already exist singleton: {singletonType.Name}");
    }

    singletonTypes.Add(singletonType, singleton);
    //管理单间加载顺序，做卸载时可用
    singletons.Push(singleton);

    singleton.Register();

    if (singleton is ISingletonAwake awake)
    {
        awake.Awake();
    }

    if (singleton is ISingletonUpdate)
    {
        updates.Enqueue(singleton);
    }

    if (singleton is ISingletonLateUpdate)
    {
        lateUpdates.Enqueue(singleton);
    }
}
```

## 第四节 多线程、单线程、Task await async的关系

### 多线程

使用多线程去执行复杂逻辑时，callback会在执行线程继续执行进行响应。

比如寻路的逻辑比较复杂抛给其他线程去处理，响应回调时也是会在寻路线程进行响应。

![image-20230308233904030](网络游戏架构设计-熊猫.assets/image-20230308233904030.png)

#### 遇到的问题

当遇到框架内的api都是单线程的api时，必须在主线程完成回调。在其他线程响应回调会导致线程竞争。

解决方法也很简单，在其他线程响应回调时把回调放到一个缓存队列中（需要同步上下文），在主线程的update里不断去取缓存队列中的响应，并去执行它。就能把回调丢回到主线程执行。(C++中的没有task而使用的手法)

详情看看MainThreadSynchronizationContext这个类

### Task

线程消耗比较大，创建的时候一般都使用线程池。Task就是线程池封装的结果。

Task 执行的线程和响应回调的线程不一致，回调的响应会丢到其他线程执行。

Task本质就是个状态机，当设置了同步上下文时，回调会被自动调整到主线程执行。 编译器帮我们做了这一步

```c#
public static async void StartTask(){
	SynchronizationContext synchronizationContext = SynchronizationContext.Current;
    await Task.Run(FindPath);
    if(synchronizationContext == null){
        //没设置同步上下文会在当前线程响应。
        SendMessage();
    }else{
        //设置了同步上下文实际会在设置的线程响应。
        synchronizationContext.post(()=>{
            SendMessage();
        },null);
    }
}
```

### 自己实现个TaskRun

```c#
 public static async Task Run(Action action)
        {
            TaskCompletionSource tcs = new TaskCompletionSource();
            ThreadPool.QueueUserWorkItem((_) =>
            {
                action.Invoke();
                tcs.SetResult();
            });
            await tcs.Task;
        }
public static async void StartTask(){
    await Run(FindPath);
    //这里把回调和多线程的调用放在同个方法执行
    SendMessage();
}
```

使用`Task.Factory.StartNew`创建可以自由调度的线程

```c#
 public static async void StartTask()
        {
     //MyTaskScheduler是自己实现的线程调度器
            await Task.Factory.StartNew(FindPath,new CancellationToken(),TaskCreationOptions.None,new MyTaskScheduler());
        }
```

### 自定义线程调度器

继承`TaskScheduler`实现自己的线程调度器

```c#
public class MyTaskScheduler:TaskScheduler
        {
            protected override IEnumerable<Task> GetScheduledTasks()
            {
                return null;
            }

            protected override void QueueTask(Task task)
            {
                //执行完回收到线程池
                ThreadPool.QueueUserWorkItem((_) => TryExecuteTask(task));
            }

            protected override bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued)
            {
                throw new NotImplementedException();
            }
        }
```



## 第五节 ETTask

### 回调地狱 Callback Hell

Task主要是为了解决回调地狱 

在没有协程和await之前，cpp主要靠函数对象模拟Lambda。 

后续谷歌推出NewCallback

C# 5.0 推出了 await async 关键字

await难以维护的操作`while await`，await all 所有任务才执行回调。

go python js ts cpp后续也推出了await关键字，但是go的await不完善，是通过线程的方式去执行。比如玩家有的操作是需要单线程等待一段事件再执行的，回调则会执行在其他线程中。而好的设计则应该是只把回调拉直，而不关心你后续实现是在多线程还是单线程。

### 回调转成Task

`TaskCompleteSource`

```c#
public async ETTask FindPath(){
    TaskCompletionSource tcs = TaskCompletionSource();
    ThreadPool.QueueUserWorkItem( state=>{
       Consle.WriteLine("FindPATH");
        tcs.SetResult();
    });
    await tcs.Task;
}
```

`CancellationTokenSource` await的取消操作

传入token，通过token状态来判断后续代码是否执行。 

### ETTask的好处

生成代码极简，去除了多线程的支持，性能最好。

对象池消除了Task GC

`TaskCompleteSource`和`CancellationTokenSource`这两个类比较庞大并且没有入池，gc问题比较严重。

去掉了ETVoid 

ETVoid对应 async void。任何异步都返回ETTask。不需要等待则直接Coroutine。操作简单。

### 线程取消

- 超级简单的ETCancelToken

  ETCancelToken替换`CancellationTokenSource`

- 协程取消判断

  ```c#
  if(cancellationToken.IsCancel()){
  	Console.WriteLine("Start cancel");
  	return;
  }
  Console.WriteLine("Start finish");
  ```

  在ETTask中判断ETCanelToken是否取消然后继续执行后面操作。而Task在取消后则抛出异常。

- ETCancelToken取消多个协程

  多个ETTask判断同一个ETCancelToken

- ETCancelToken的必要性

  尽可能设计一个await的取消方式，否则后续维护扩展非常困难。

### awaitable

#### GetAwaiter

c#提供的`GetAwaiter`的机制，只要对象有一个成员方法或者静态方法名为`GetAwaiter`，就可以使用await的语法。

#### Unity yield转换

本质上也是回调操作，把yield用await的形式更加简单。

```c#
//unity中yield都会返回AsyncOperation的子类
public static async ETTask GetAwaiter(this AsyncOperation asyncOperation){
    ETTask task = ETTask.Create(true);
    //SetResult执行后会回到await后的操作。
    asyncOperation.completed += _=>{ task.SetResult();};
    await task;
}
```

```c#
public static async ETTask<string> HttpGet(string link){
    try{
        UnityWedRequest req = UnityWebRequest.Get(link);
        //req.SendWebRequest()会返回UnityWebRequestAsyncOperation，继承于AsyncOperation
        await req.SendWebRequest();
        return req.downloadHandler.text;
	}
    catch{
        throw new Exception();
    }
}
```

## 第五节 -2 ETTask源码分析

用反编译工具`.NET Reflector`查看ETTask实现。

这里需要反复看生成概念。

本质上是基于状态机的实现，执行时通过判断ETTaskCompleted的值来判断是否走到后面的逻辑，如果需要等待则将状态机的`MoveNext`方法传到ETTask的CallBack中。通过状态机的状态变化继续后面的逻辑。 ETTask的`SetResult`操作会触发回调，执行状态机的`MoveNext`。

实际上是把await前的代码和await后的操作，各放在一个状态中，通过状态机切换来执行。保证了上下文的统一。

多个await会生成多个状态机

#### ETTask

只要用了`ettask.Coroutine()`在编译后会生成一个`ETAsyncTaskMethodBuilder.Create()`

#### ETAsyncTaskMethodBuilder

struct类型，包含一个ETTask。

在方法执行了Coroutine编译后会对应生成一个相对的struct，继承于`IAsyncStateMachine`。生成一个状态机，根据state参数执行相对应阶段的代码。

#### ETVoid

#### ETAsyncVoidMethodBuilder

#### ETTaskCompleted

返回完成状态，基本是true

#### ETAsyncTaskCompletedMethodBuilder

### 协程的使用

用协程简化工作流程。

`int result = await OpenBox();`弹窗时返回点击按钮的type做相应的判断，简化在窗口里写逻辑，逻辑上更清晰。(有点像VB的弹窗返回值

 `await MoveTo();`

`await ChangeScene();` 切换场景的操作写成一个方法，await后执行切换场景完成后的代码。

`await CastSpell();` 释放技能，技能成功或失败后的操作。比如失败时使用道具，成功后捡道具。如果用事件则会变得很复杂。 

熊猫哥举了个例子，比如自动寻路时，需要通过几个场景的传送门才能到达最终场景。先把场景选出来，给每个场景写一个最短路径的寻路方法。根据读配置去执行相应的寻路方法。只需要通过一个while循环就能到达最终目标位置。

把逻辑异步化后，逻辑更清晰，只需要对内容进行封装抽象不需要再关心后续的逻辑了。

## 第六节 计时器

`TimerComponent`

### 需求场景

- UI倒计时
- 网络超时
- 技能释放
- buff超时删除，定时事件

### Task.Delay的问题

C#提供的定时器`Task.Delay`。

- 跨线程
  - `Task.Delay`是跨线程的，会把await的回调放在其他线程执行。
- 性能
  - 如果需要把回调设置到主线程，就需要设置同步上下文`SynchronizationContext synchronizationContext = SynchronizationContext.Current;`。把action post到主线程，性能很糟糕
- CancleToken抛异常
  - 抛异常的性能问题
  - 不执行后续操作
- GC
  - 基于Task实现 有GC

### 实现

#### 代码实现

##### 相对时间

`public async ETTask WaitAsync(long time,ETCancellationToken cancellationToken = null)`

##### unix绝对时间

`public async ETTask WaitTillAsync(long tillTime,ETCancellationToken cancellationToken = null)`

相对时间的会跟随帧率 或 线程情况受影响。而绝对时间则是跟随unix时间。在时间达到时，无论什么情况都会执行。

##### 计时器

`public long NewOnceTimer(long tillTime,int type,object args)`

为什么不用callback？

计时器里可能会有泄露，方便查找泄露。callback没法热重载，基本不用callback。

跟WaitAsync的区别？

时间长时，用`NewOnceTimer`，可以热重载。而`WaitAsync`不能热重载。

#### 数据结构

MultMap 管理时间线，在每个时间点插入一个list管理多个计时器。插入list的操作有gc，用对象池创建的话会有回收问题，一直创建池子只会越来越大，在切换场景的时候回收。

Remove细节，只从timerActions中删除。不删除MultMap 管理的计时器，MultMap管理的List插入删除都会影响性能。时间到了从MultMap 取出执行时，判断是否在timerActions中，如果在再执行。

WaitAsync ETCancellationToken怎么判断去取消。

## 第七节 协程锁

`CoroutineLockComponent`

### 使用场景

- 协程并发造成协程竞争，类比于线程竞争
- unity资源加载
  - 同时异步加载同一个资源会报错
  - 如果打标记后续逻辑比较不好扩展，比如要做await操作。
- 加载mail数据
  - 不同服务器玩家数据的竞争
- unit消息队列，上线下线
  - 玩家下线了，但是有些异步操作还没完成。
- 数据库查询保存队列，防止并发过多
  - mongodb数据的并发数量是有限的。

用了协程锁后，协程则是并列进行。

### 死锁

#### 协程锁中再次获得同一把锁

![image-20230314225046861](网络游戏架构设计-熊猫.assets/image-20230314225046861.png)

#### A B互相等待 

#### 想象不到的死锁

![image-20230314225755691](网络游戏架构设计-熊猫.assets/image-20230314225755691.png)

两条没有关联的消息正好在同一时间请求，请求的内容都需要用到同一把锁。就造成了死锁。

这种情况比较罕见，要么改成请求锁的地方统一通过转发形式。要么干脆直接不处理了。

### 协程队列实现

CoroutineLockComponent

![image-20230314230323393](网络游戏架构设计-熊猫.assets/image-20230314230323393.png)

- 协程锁划分类型
  - 不同类型的锁没必要等，比如资源和数据。
- 同一个类型，再根据id划分协程锁队列。
- 同一个类型，并且id相同则在同一个队列中，并列执行。

CoroutineLockQueueType

CoroutineLockQueue 对象池

### 问题

为什么不用池？不用struct？

超时实现

## 第八节 协程同步

三件套`ETTask`、`协程锁`、`WaitAll`

在使用waitAll时需要考虑是否能并发，是否需要并发。

`ETTaskHelper.WaitAll`

### 使用场景

#### 资源加载并发

`ResourceComponent`实现了并发加载资源

![image-20230314232242465](网络游戏架构设计-熊猫.assets/image-20230314232242465.png)

#### 机器人登录并发

![image-20230314232906957](网络游戏架构设计-熊猫.assets/image-20230314232906957.png)

![image-20230314232915651](网络游戏架构设计-熊猫.assets/image-20230314232915651.png)

每个流程都可以实现并发

### WaitAll实现

#### 线程同步barrier

可以参考barrier

1. 主协程要阻塞住
   - 主协程wait
2. 所有子协程执行完，要通知主协程往下执行
   - 子协程执行完有个回调，至少有个setResult的操作
     - 用计数形式，每执行完一个子协程，count-1，count=0时表示子协程都执行完毕。
   - 主协程在所有子协程都执行完后才开始执行，就需要判断。
     - 在主协程开始时，判断计数是否为0，为0时直接执行。不为0时创建个ETTask等待。
3. Cancel的判断
   - WaitAll取消的操作

### WaitAny

有任一一个协程执行完则返回。

#### 实现

计数设置为1，执行完一个-1，count<=0返回

## 第九节 ID、TimeInfo、ObjectPool

### ID

对应类`IdGenerater`

#### ID跟InstanceID

##### ID是逻辑上的，InstanceID是对象的

##### ID可以重复，管理器管理，而InstanceID是全局唯一的

#### 为什么需要InstanceID？

##### InstanceID表示对象的唯一性

对象可能会被释放或者清除，通过InstanceID判断对象是否存在

##### InstanceID有位置信息

InstanceID拥有时间、进程号

##### InstanceID能方便区分对象进入对象池再被使用

在await等待时当持有的unit可能在某个操作被对象池回收，后再被创建。持有的unit已经变成了新的unit造成逻辑错误。

InstanceID被池回收后再创建，InstanceID发生变化。在await操作时判断前后InstanceID是否一致。

#### ID的构成

`long`类型 64位

- Time 30bit  34年
  - 不用从1970开始，可以从项目发布时间开始，还能用34年
- Process进程号 18bit 1024*256
  - 一个区大概使用256个进程(根据游戏类型调整)，可以支持1024个区
- 自增 16bit 65535
  - 当一秒内的自增id超过范围时，借用下一秒的

#### UnitID构成

- Time  30bit 34年
- Zone 10bit 1024个区 跨服用
  - 当出现跨服活动时，很方便的通过zone来做区分
- ProcessMode 8bit Process % 256
- 自增 16bit 65535

#### InstanceID构成

- Time 28bit  当年开始的tick
  - 生命周期比较短，不需要那么长的 time
- Process进程号 18bit 1024*256
  - 一个区大概使用256个进程(根据游戏类型调整)，可以支持1024个区
- 自增 18bit 65535 *4
  - 数量比较多，增加自增率

### TimeInfo

对应类`TimeInfo`

- Unix Time 自1970年1月1日以来的毫秒
- ServerMinusClientTime
  - 服务器时间  -  客户端时间得到的时间差。在 ping的过程中获取。
  - 客户端时间 + 与服务器的时间差 = 服务器时间
- ServerTime、ClientTime
  - 对于服务器而言，ServerTime和ClientTime是一样的，对服务器而言不需要考虑客户端时间。
  - 对客户端而言，ServerTime就是  客户端时间 加上 与服务器的时间差获得的。
- 性能优化
  - 在ClientNow中 计算时间用到Ticks，Ticks的操作非常耗时。

### ObjectPool

mono的垃圾回收很垃圾。

在异步代码里，处处使用对象池很有问题。在每个操作都要判断是不是新的对象，漏了一个就有很大的问题。

有些对象池有定时回收的功能，这个功能的缺陷在于，在某一帧可能会回收大量对象，加深了那一帧的时间。

ET的设计则是将对象池设置个最大容量，超过最大容量时则不入池，避免内存占用过大。

在一些场景切换中也可以对对象池进行清理，避免没有意义的内存占用。

## 第十节 配置Excel、NLog、Options

### Option

`Options`

- Options类 示例
- 长名 短名 Required Default HelperText
  - `OptionAttribute` 
  - Required 为false时不强制要求带参数
- 序列化 反序列化
  - 序列化和反序列称unix和linux命令行风格的字符串
- 起服命令参数
  - option一般用于服务器启动，起服命令参数一般用于创建进程的配置信息。
- GM指令参数，手动解析？
  - GM指令如果是命令行最好使用option的形式来配置。optin提供静态检查，不容易出错。

### Log

![微信图片_20230320090859](网络游戏架构设计-熊猫.assets/微信图片_20230320090859.jpg)

- Logger单间类
- ILog接口，策略模式
  - 策略模式，客户端使用UnityLogger，服务端用NLogger
- LogLevel
  - 提供Log等级，来按照等级进行输出。开发模式，测试模式和线上模式
- Conditional
  - 当有些日志需要进行拼接的操作时，拼接消耗性能，就给个宏定义判断。
  - 通过打标签的形式对指定 Log函数进行标记，等有了宏定义之后才生效。
  - 一个函数可以定义多个宏
  - .NET的新特性，可以使用DefalutInterpolatedStringHandler来减少字符串拼接带来的GC
- LogTrace
  - 当需要查看日志的堆栈时可以用LogTrace，函数内会创建个堆栈。这里可以看看堆栈的逻辑。

### NLog配置

对应config里的参数

- Variables
  - 通过变量修改Config里的配置，来达到指定参数的日志输出
  - LogManager.Configuration.Variables
- rules
- targets
- async、buffersize

### Excel

- StartConfig
  - 启动时通过命令行选择加载指定的配置
- C S #
- patial
  - 有些配置，不方便填类型比如 ip地址等等
  - 通过patial扩展想要的类型，通过proto反序列化时赋值。
- KV
  - 通过key value的形式配置buff

### 配置用时再加载

节省内存

懒加载减少同时加载造成的cpu过载

## 第十一节 Why not 继承，多态，组合？

### 成员继承的问题

#### 类层级调整复杂、耦合，一个变化回影响很多子类

​	当层级变多了后，插入一个新的对旧的逻辑都都会有影响

#### 继承成员随意组合问题

#### 接口 + 组合？组合优于继承？

​	每个类都继承了接口的话，都需要额外实现。

​	缺乏动态性。当有一个功能，当前不开放但是之后开放。如果是接口，代码实现则需要预先实现，是否开放变成了时机的问题。浪费空间

​	特殊性影响了普遍性，可能并不是所有成员都拥有的功能，则需要给每个成员都添加对应的逻辑。

​	临时接口跟成员数量极多。比如各种种类的buff。

​	成员容易随意放置，没有规范。

​	patial分开逻辑？没有解决根本的问题，内存占用巨大。不需要的成员拥有了不需要的字段。

### 类方法的问题

函数跟数据混在一起，重构困难。当需要挪出逻辑时，会有private字段限制，不好挪动。

类和类之间方法互相调用，耦合，重构困难。

静态方法和类方法，界限不清晰。

### 虚函数问题(多态)

行为跟类型绑定，类型数量会爆炸

当一个类拆的不够细时。由于子类做不到任何成员组合，子函数会巨大。

不同类型经常写差不多的方法

### 综合

学习成本极大，打补丁的设计模式太多。

人员要求太高，经常设计不够细致。

如果没有统一标准，代码维护困难。

### Unity组件的优点

成员自由搭配

成员动态插拔的，内存占用率高。

方法也是动态插拔的，更合理，更不容易出错。

临时数据不会导致信息爆炸，成员，方法

代码可读性高，因为内部实现少都是组合。

### Unity组件的缺陷

数据跟方法没分离，容易耦合，互相调用。

事件方法基于反射，性能有些损失。

GameObject过于庞大，里面的东西过多，只需要纯逻辑时不需要view。 

没有替代多态的解决方案。

组件无法再挂组件，组件无法再有child。

### ECS的问题

Entity只有一个ID，全是Entity。全是entity找bug起来很复杂

组件是strust，限制太大用起来很难受

非树状结构，不符合对世界的描述，工厂的管理模式。

组件无法再挂组件，过于扁平，组件无法再有child

## 第十二节 实体组件系统

### Entity Component System

AddComponet、RemoveComponet、生命周期等等接口名与生命周期都和Unity保持一致。

#### Entity和Component合并。原因？区别？

Entity和Component很类似，功能开发时逻辑很容易互相嵌套，不容易区分。只有Entity能挂组件很不灵活，在线上环境中Component需要扩展成Entity很难进行扩展因为数据已经是Component的形式。

#### 数据跟方法完全分离

#### Entity不能继承

用组件代替继承，需要什么数据挂在需要的组件。

#### Entity树状无限嵌套

大世界概念，比较容易描述游戏需求。

#### 跟传统ECS的区别

传统ECS的System更多是成员的形式。

传统ECS强调组件的筛选

### ET组件数据跟方法分离的好处

没有耦合，没有设计模式，学习简单，重构简单

热重载容易

多态实现简单，能基于任何字段做逻辑分发

### 逻辑分发-多态

#### if else

#### switch

#### Dictionary<int,Action>

状态注册，相比switch而言优化了寻找时的复杂度。

问题在于需要手动注册状态，删除时需要手动删除相对而言比较麻烦

#### ET的分发形式，基于Attribute的自动注册

eventsystem

### Entity树

#### Entity的parent

最顶层的Scene没有parent

Entity被反序列化出来时是没有parent的

#### Domain

每个Entity都有一个Domain字段，记录在于哪个场景下

在找中间某个节点时，防止写了过多的getParent。

#### 对象生命周期管理的重要性

创建对象时，谁去管理释放。谁去管理对象的生命周期。

如果通过单间管理对象的生命周期，又缺少了对单间生命周期的管理。写多了容易遗漏。

通过父级来管理孩子，父级移除时移除自身挂在的child。

#### UISceneComponet ResourceSceneComponent Timer等等

按Scene挂ui，根据Scene的生命周期进行资源回收。

创建时需要想清楚，需要让谁进行管理。

### 最佳实践

不建议把Entity做为另一个Entity的成员，要么作为组件，要么作为Child。

异步代码，容易出现对象消失，引用还在的情况。特别是用了对象池更危险，做分析器禁止

服务端逻辑帧一般不用Update和LateUpdate。服务器的一帧1毫秒，实际上不需要这么频繁，用Update100ms或者定时器来实现。

### Entity代码详解

Entity内，存放Component以Type为key ，一种Type的Component只能存在一个。

存放AddChild则是以Id为key。

#### EntityStatus

8位的枚举，每一位都记录了一个信息。

#### SetParent

Parent{Set方法}

严格限制parent必须要有domain，parent必须在数据树上。

#### ComponentParent

只能通过AddComponent来添加。

#### Domain

根节点的Domain为自己，其他节点的Domain为父节点的Domain

如果是通过反序列化出来的Entity则没有domain，这时候需要递归把children的domain都设置一遍

#### DB

如果Child继承于ComponentDB或者ChildDB，则会加到componentsDB或childrenDB内。表示需要持久化。

## 第十三节 EventSystem

**Type.GetType在IL2CPP中性能很差**

### 实体组件生命周期相关

Awake Update LateUpdate Destory

### Publish 自定义的抛事件方法

##### 类比dll的单项依赖，防止互相依赖

##### 模块隔离

##### 同步异步

异步Publish，等待订阅者完成操作后，发布者才会进行后面逻辑

##### SceneType

all in one的设计，用来区分是客户端还是服务端

服务端也能用来做进程间的限制

##### 全局事件(静态事件)

动态事件的绑定都有一个绑定的过程，需要额外管理什么时候监听并且什么时候释放。在查看代码时，需要查看监听的绑定调用，会降低可读性。

不需要每个监听类都有一个callback，只有全局的callback。

### Invoke

相当于回调。取决于怎么去触发回调。

根据id分发。程序启动时把响应方法注册进EventSystem内。

### Invoke和Publish的区别

Publish抛出去不关心结果不关心订阅者的，Invoke是主动调用(类似函数)需要知道函数真实存在。

Publish区分SceneType，Invoke没有区分

Publish没有分发作用，Invoke带有分发作用

Publish一对多，Invoke一对一

Publish跟Invoke命名不同，Publish命名跟时间点相关，Invoke命名跟使用者相关

### TypeSystem

每个Type都有一个对应的OneTypeSystems

#### OneTypeSystems

OneTypeSystems中的QueueFlag记录实现了哪些生命周期，ISystemType中的GetInstanceQueueIndex可以获取到 生命周期的Index

当Entity实例化时通过OneTypeSystems取生命周期的Flag

### Queue

按照生命周期的Flag来缓存需要生命周期的组件ID队列，因为组件可能被对象池回收，所以缓存组件ID

## 第十四节 序列化反序列化

### 使用场景

Excel配置文件，编辑器配置文件，大小跟速度都无所谓

网络消息 大小速度很重要

Entity对象，很复杂，需要支持继承等复杂特性

数据库，mongodb

命令行

### 库的选择

Google Protobuf 性能最好，代码生成复杂不容易扩展，容易无gc

Protobuf-net 性能较好，代码简洁，使用最广泛。使用反射机制不好定制

MessagePack 性能较好，代码简洁，其他语言使用少

Mongo.Bson 性能较差，功能最强，并且支持Json

选择Protobuf-net跟MongoDB，满足任何需求

#### Protobuf-net

##### 继承

为了支持protobuf的格式，需要在父类上打标签表示继承关系

```c#
[ProtoContract]
[ProtoInclude(3,typeof(BB))]
public class AA{
    [ProtoMember(1)]
    public int a;
    [ProtoMember(2)]
    public float3 pos;
}
public class BB:AA{
    public int b;
}
```

##### struct

```c#
RuntimeTypeModel.Default.add(typeof(float3),false).add("x","y","z");
AA aa = new AA(){
    a =1,
    pos = new float3(1,2,3)
}
```

#### Mongo Bson

MongoDB的C#库，把C#对象序列化成MongoDB可以用的格式，也可以转换成其他格式，并且支持嵌套。

##### 特性

- Bsonld
  - 每条数据都需要有一个Bsonld，如果没有赋值会默认给个96位的Id
- BsonElement
  - private字段需要序列化字段的标签
  - 可以重命名，可以取个别名可以节省空间。序列化反序列速度也能提升
- Bsonlgnore
  - public字段不需要序列化的标签
- BsonDefaultValue
  - 没有赋值则取默认值
- BsonlgnoreIfDefault
  - 如果是默认值则 序列化过程中不进行序列化

##### 子类默认不能反序列化成父类

`BsonIgnoreExtraElements`加上则在反序列化过程中排除多余的字段

每个都加比较麻烦，Mongo Bson提供了默认操作

```c#
// 自动注册IgnoreExtraElements
ConventionPack conventionPack = new ConventionPack { new IgnoreExtraElementsConvention(true) };

ConventionRegistry.Register("IgnoreExtraElements", conventionPack, type => true);
```

##### StructBsonSerialize

注册了结构体后可以反序列化成结构体

##### BsonDictionaryOptions

字典序列化时，默认的key需要为string。因为默认的json库的key是string类型

`BsonDictionaryOptions`提供了多种字典序列化方式

一般用ArrayOfArray的形式

##### BsonClassMap.LookupClassMap

mongo在序列化时会记录继承关系，反序列化则会成功。

但是如果直接进行反序列化，mongo默认不知道继承关系则会失败。 

把每个类型都进行注册`BsonClassMap.LookupClassMap(type)`

##### 标准json格式

MongoHelper.ToJson时可以传入设置，则为标准json格式。

### Entity

ISerializeToEntity ComponentDB ChildrenDB

DeserializeSystem 反序列化后执行的System

## 第十五节 Network-1

- socket
- IP
- Port
- bind
- accept
- connect
  - 分为阻塞和非阻塞
- read
  - 分为阻塞和非阻塞
  - socket有缓冲区，read需要等缓冲区满了才会进行读取。
- write
  - 分为阻塞和非阻塞
  - socket有缓冲区，write等缓存去满了才会进行write操作

### ET的需求

#### 一个主线程 一个网络线程

网络独立线程后不好做，对客户端而言很难实现0gc的操作不能用对象池，客户端对网络性能的需求没那么高。

对服务端而言，不是复杂场景下单线程网络线程基本满足需求。

#### 单进程有多个监听(accept)	all in one

#### 序列化跟反序列化在网络线程，减轻主线程压力

如果放在主线程序列化和反序列化就会造成，在序列化后发送请求时，网络线程可能还需要等待一段时间后才会真正发送。这个时间片段内主线程又重新发送了相同的请求，如果使用了对象池就会修改到前面请求的数据。因为对象池是单线程的。

### ET的设计

抽象出NetService来处理主线程跟网络线程通信

抽象出AService来处理监听，管理连接

抽象出AChannel(网络连接)来做消息收发

多个AService注册到NetService

主线程封装NetComponent处理收到的连接，消息，错误

主线程封装Session做主线程消息发送，以及rpc

### NetServices线程安全队列

NetServices主要负责主线程跟网络线程之间的通信

主线程->网络线程：

1. 创建连接创建Channel
2. 发送消息给Channel发送

网络线程->主线程: 

1. 接收连接创建Session
2. 接收消息回调主线程
3. 网络错误回调

![image-20230720100918090](网络游戏架构设计-熊猫.assets/image-20230720100918090.png)

#### 主线程回调函数

- acceptCallback
- readCallback
- errorCallback

#### Service管理

```c#
private readonly ConcurrentDictionary<long, AService> services = new();
```

#### 多线程注意事项

- 除了线程队列，一个成员永远只能一个线程操作

  - 一个方法永远只能跑在一个线程中，如果方法内操作了成员非常危险。

- 非常清楚每个字段是哪个线程操作的，绝对不能出错

- NetOperator，跨线程消息要注意

  - 只通过跨线程的消息做跨线程的处理

  - 只通过双队列进行跨线程的数据传递，通过Update来取出双队列的数据。

   ```c#
    private readonly ConcurrentQueue<NetOperator> netThreadOperators = new ConcurrentQueue<NetOperator>();
    private readonly ConcurrentQueue<NetOperator> mainThreadOperators = new ConcurrentQueue<NetOperator>();
   ```

## 第二十三节 AI

### AI的用处

1. 怪物、NPC等行为
2. 子弹
3. 机器人
4. 托管

### AI常用实现方案

- 状态机
  - 每两个状态都可能发生转换，复杂度是N的平方
  - 节点与节点之间耦合会很严重
- 行为树
  - 每个方法都要包装成节点，节点太多
  - 树太大不好编辑
  - 牵一发而动全身，一个变量的调整可能会导致顺序的调整
  - 表达弱，难以阅读，难以重构
  - 协程的支持比较原始，等待的操作会被包装成节点
- 深度学习

### AI的本质

根据当前的状态，执行一个行为。

### ET改进

直接用代码编写AI

​	复用节点改为复用函数。一个行为由多个函数组成。

协程化，每个节点是一个协程

​	在行为内隔一段时间进行条件的判定，当条件满足时打断其他的行为，并执行满足条件的行为。

节点包含条件跟行为

​	把行为进行抽象，而不是把状态进行抽象。