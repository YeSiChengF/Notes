## 面试QA 1.0

### 1.Q：你所知道的UI框架？

A：

### 2.Q：DrawCall是什么？比如什么操作会产生dc？如何优化？

A：CPU每次准备数据并通知给GPU的过程就称为一个DC。材质相同、相同组件位置相邻、将频繁改动的组件显示在最上层

### 3.Q：讲述下拆装箱操作？

A：装箱就是隐式的将值类型转换成引用类型，拆箱就是显示的将引用类型转换成值类型。值类型在进行装箱后会在堆数据内新创建一个当前的值类型和对应值类型的值。

### 4.Q：简单描述下ECS框架

A：面向数据，可以提高CPU的缓存命中率。Entity一个没有任何意义的实体可以是任何东西。Component存储数据的组件。System用于处理数据的系统，写逻辑的地方。优势在于可以数据和显示分离，单纯对数据做压力测试。劣势在于数据访问变复杂。

### 5.Q：GC是什么？为什么会产生GC？怎么优化？

A：GC是CLR堆管理器上控制内存分配和释放的组件。当堆上可分配的内存不足时就会触发GC去回收未使用的对象。

会从栈引用开始跟踪，如果无引用堆里的数据，认定堆数据不再使用，开始回收内存。但是GC的操作是非常复杂的会占用很多CPU时间，对于移动设备来说频繁的垃圾回收会严重影响性能。

下面的建议可以避免GC频繁操作。

1. 减少用new创建对象的次数，在创建对象时会产生内存碎片，这样会造成碎片内存不法使用
2. 使用公用的对象（静态成员，常量），但是不能乱用，因为静态成员和常量的生命周期是整个应用程序。
3. 在拼接大量字符串时StringBuilder。在使用注意，创建StringBuilder对象时要设置StringBuilder的初始大小如：StringBuilder sbHtml = new StringBuilder (size);
4. 使用object pool(对象池)

### 6.Q：单例和静态类的差别？

A：生命周期不同，单例的生命周期在于new对象时开始，而静态类的生命周期是从程序启动就开始，为整个程序的生命周期。

### 7.Q：为什么离开泡游

A：没有转正机会，未告知转正名额和转正时间。三个人转正。刚开始参加工作，适应过程稍久。

### 8.Q：在泡游主要做了什么

A：在《极品芝麻官》U3D版中，使用UGUI的不同组件实现不同的界面功能，处理UGUI界面的性能优化。UGUI性能优化主要在于取消勾选不必要的射线检测、相同组件位置相邻减少合批次数、使用TextMeshPro代替Text、文字组件尽量显示在图片上方，因为文本经常修改触发渲染。主要在于组件的命名规范，使用`puerTs`的 `JsBehaviour`关联需要设置的组件， `JsBehaviour`模拟Unity中的`MonoBehaviour`。 

用json写cache的结构，用ts编写处理cache的逻辑，用`jestjs`测试框架请求协议对逻辑进行验证

 编写Editor批量处理工具，将人物服装图片裁剪空白像素，向上或向下扩展成2次幂的宽高，2次幂方便运算在Unity中也能压缩的更小。再根据原始坐标和裁剪后的坐标生成json文件，提供给后续开发。

### 9.Q：在网趣主要做了什么

A：主要做了兵卡系统、个人中心系统。兵卡系统主要体现在升级、合成、分解，配件的穿戴、配件打造(涉及便携打造，使用递归)。协议主要使用`Protobuf`。

基于树形结构端实现的客户端红点系统，由于没有处理唯一id的功能，所以在节点内设有Root节点。Root节点管理所有依赖于这个Root节点的节点，Root节点必须为唯一的id（如道具、人物的唯一id、自己设置的id字段）。在红点System中，通过一个字典管理所有Root节点。节点内存有Root节点信息、自身信息、父级节点和所有子级节点。获得值时，向上通知。当有子节点移除时，遍历所有子节点统计红点数量。

绑定设有静态绑定和动态绑定，动态绑定通过Event触发。静态绑定现在是在节点内存放一个物体。

由于兵卡系统涉及的功能点较多、相同数据可能会有不同的存放和排列方式。创建了一个List字典的容器，一个字典管理多个List。一个字典存放所有的元素。在add的时候需要传入存储入比如哪个名字的list，需要读取时的id是什么(管理所有元素的字典的key值)，需要存放的元素。这样就保证了元素不会重复存放，又能通过list实现功能所需要的元素个数或排序。

### 10.Q：Protobuf怎么解析？



### 11.Q: 什么操作会导致内存泄漏？

A：内存泄漏主要体现在申请了内存却没有及时释放，当发生多次相同操作导致内存持续泄露，最后因为内存占用过大而导致游戏崩溃。

Q：怎么查找内存泄漏？

### 12.Q：常用的设计模式

A：

#### 创建型：

1.工厂模式，工厂模式生产对象我们只需要跟工厂打交道，根据需求在工厂里更换对象，工厂模式最大的优点就是解耦。主要体现在提供创建产品的接口、完整具体产品的创建、展示产品的主要特性和功能、实现抽象产品所定义的接口。

使用到工厂模式的地方，UI框架中的Window类提供的各种状态方法。2D游戏中的不同枪支不同子弹。

#### 行为型：

2.策略模式，定义一系列方法，将它们进行封装 并且使它们可相互替换。使得方法可独立使用它的客户而变化 

缺点：使用者必须知道所有策略，策略过多时类会很大。

比如子弹类，不同武器射出的子弹类型和子弹数量都不同，可以创建多个子弹策略，根据需要获取对应类型子弹。

3.观察者模式， 定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。 

当网络协议监听到指定的handler时，就是触发所有这个handler的方法

#### 结构型：

桥接模式，将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。

面试题中的鸭子有不同颜色的实现。

### 13.Q：ILRuntime怎么热更？

A：通过热更DLL文件实现热更。ILRuntime借助Mono.Cecil库来读取DLL内的信息，最终得到方法的IL汇编码。在通过IL解释执行虚拟机来执行DLL中的代码。

### 14.Q：什么是线程安全什么是线程不安全？

A：线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。

线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据

### 15.Q：Dictionary和List 的区别？存储方式？

A： List是对Array的泛型封装，数据结构上为线性表。每次扩容都会扩展到原来的两倍，所以最好在初始化时就规定好容量大小。由于是基于Array实现的，所以在存储方式上存储位置也是连续的。

Dictionary是哈希表的泛型封装，宏观上不是连续的，是根据Key而根据Hash算法分析产生的内存地址