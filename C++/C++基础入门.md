# C++基础入门

### 学习路线

计算机组成原理

https://www.bilibili.com/video/BV1EW411u7th?from=search&seid=11558880190937398744&spm_id_from=333.337.0.0

深入理解计算机系统

计算机体系结构量化分析

## 1.C++初识

### 简介

C++是C语言的超集，合法的C程序都是合法的C++程序

通常使用 .cpp .cp .c后缀名

### 启动框架

```c++
#include<iostream>
using namespace std;

int main(){
	int a=10;
    cout<<"a="<<a<<endl;//endl代表这行结束
    system("pause");
    return 0;
}
```

使用"\n"代替endl

```c++
#include<iostream>
int main(){
    int a=10;
    std::cout<<"a="<<a<<"\n";
    return 0;
}
```

### 三字符组

以两个？开头

现在默认不自动替换，需要 设置编译器命令行选项/Zc:trigraphs 

| 三字符组 | 替换 |
| :------- | :--- |
| ??=      | #    |
| ??/      | \    |
| ??'      | ^    |
| ??(      | [    |
| ??)      | ]    |
| ??!      | \|   |
| ??<      | {    |
| ??>      | }    |
| ??-      | ~    |

### 常量

#### 定义常量的两种方式

#define 宏常量	**通常在文件上方定义**，表示一个常量

const关键字

```c++
#define acc 888
int main(){
    const int abb=5;
    cout<<"acc="<<acc<<endl;//报错，宏常量不可修改
}
```

## 2.数据类型

### 整型

short 2个字节(-32768-32767)	int 4个字节	long 4个字节	long long(长长整形)8个字节

short<int<=long<=long long

### sizeof关键字

统计数据类型所占用内存大小

可以传入变量或者数据类型进行判断

```c++
cout<<sizeof(int)<<endl;
short num1=10;
cout<<num1<<endl;
```

### 类型的最大最小值

```c++
namespace std;
int main(){
	cout << "\t最大值：" << (numeric_limits<long>::max)();  
	cout << "\t最小正数：" << (numeric_limits<long>::min)() << endl; 	cout << "\t最小值(为负数或0)"<<std::numeric_limits<T>::lowest()<<endl;
}
```

### typedef声明

可以对一个已有类型取别名

```c++
typedef int feet;
feet num=10;
```

### 实型(浮点型)

float 4字节 7位有效数字	double 8字节 15~16位有效数字

```c++
float f1=3.14;//不加f 默认识别为double类型，再转换赋值给float
float f2=3.14f;
float f3=3e2;//3*10^2
float f4=3e-2;//3*0.1^2;
```

### 字符型

char 在c和c++中只占1个字节

字符变量不是对字符本身进行存储，而是将**对应的ASCII码**进行存储

```c++
char ch='a';
//输出对应的ASCII码
cout<<(int)ch<<endl;
```

### 字符串型

需要使用头文件

```c++
#include <string> //头文件(类似类库)
```

### 布尔型

非0的数值都可以代表true,0代表false

```c++
bool flag=true;
cout<<flag<<endl;//1
bool flag=false;
cout<<flag<<endl;//0
```

### 数据的输入

关键字 cin

```c++
bool isHave;
cin>>isHave;
```

## 3.算数运算符

### 除法/	 

除数和取模数不能为0，否则为非法操作

### 取模%

两个小数不可以做取模运算

只有整型变量可以进行取模运算

## 4.程序流程结构

### break

退出当前循环

### continue

跳过本次循环

### goto

无条件跳转代码,跳转至标记点

`语法：goto 标记;`

```c++
int main(){
	goto FLAG;
    cout<<"!"<<endl;
    
    FLAG:
    cout<<"@"<<endl;
    
    return 0;
}
```

## 5.数组

### 一维数组

`int arr1[] = { 1,3,4,5 };`

**必须进行初始化操作**

名称用途：

1. 统计整个数组在内存中的长度 	`sizeof(arr)`
2. 获取数组在内存中的首地址(16进制) `cout<<arr<<endl`

查看数组元素地址 `cout<<&arr[0]<<endl`

数组名是常量已经指定了内存地址，不可以进行赋值操作

不能将一个数组直接赋值给另一个数组

### 二维数组

C++会自动划分元素

第四个元素自动划分为第二行中`int arr[2][3]={1,2,3,4,5,6}`

自动推算出行数`int arr[][3]={1,2,3,4,5,6}`  

## 6.函数

### 函数的分文件编写

1.创建后缀名为.h的头文件

2.创建后缀名为.cpp的源文件

3.在头文件中写函数的声明

4.在源文件中写函数的定义

## 7.指针

### 指针的概念

指针的作用：`可以通过指针间接访问内存`

内存编号从0开始，用十六进制数字表示

可以利用指针变量保存地址

**指针实际上记录的就是地址**

**在函数中，值类型需要按地址传递都是以指针形式**

指针类型在32位系统占用4个字节

1.定义指针

`数据类型*指针变量名`指针变量名一般用 p(pointer)

让指针记录变量地址 `&`

```c++
int a=10;
//定义指针 数据类型*指针变量名
int * p;
//让指针记录变量a的地址
p=&a;
//修改指针指向地址的值
*p=100;
```

2.使用指针

可以通过解引用的方式来找到指针指向的内存 `*`

可以修改或读取指针访问的内存

### 空指针和野指针

#### 空指针

空指针：`指针变量指向内存中编号为0的空间`

用途：初始化指针变量

注意：空指针指向的内存是不可以访问的

```c++
int * p = null;
//空指针不能复制会报错
*p=100;
```

#### 野指针

指针随便指向的一个内存地址，可能没有访问过会报错

在程序中需要避免出现野指针

```c++
int * p =(int)0x1100
```

### const修饰指针

#### 常量指针

指针的指向可以修改，但是指针指向的值不可以改

指针指向的内存地址可以不同，但是内存地址里的值需要相同

```c++
const int * p= &a;
```

#### 指针常量

指针指向的内存地址不能修改，地址内的值可以修改

```c++
int * const p = &a;
```

const修饰指针和常量

```c++
//地址和值都不可以改
const int * const p= &a;
```

### 指针和数组

利用指针访问数组的元素

```c++
int arr[10]={1,2,3,4,5,6,7,8,9,10};
int * p =arr;//数组首地址(数组第一个元素的地址)
cout << *p << endl;
//16进制++
//获取数组第二个元素
p++;
cout << *p << endl;
```

### 指针和函数

通过指针可以将值类型按引用类型方式传递

```c++
int a=10;
int b=20;
void swap(int * p1,int * p2){
    * p1=20;
    * p2=10;
}
swap(&a,&b);
```

### 指针、数组、函数

```c++
int arr[10]={4,3,6,9,1,2,10,8,7,5};
//数组长度
//数组所占用内存大小/单个元素占用内存大小=数组长度
int len=sizeof(arr)/sizeof(arr[0]);
```

## 8.结构体

### 结构体数组

将自定义的结构体放入数组中方便维护

`struct 结构体名 数组名[元素个数] = {{},{},.....}`

### 结构体指针

利用操作符`->`可以通过结构体指针访问结构体属性

```c++
struct student{
    string name;
    int age;
    int score;
};
```

```c++
struct student s={"张三",18,100};
student * p= &s;
```

### 结构体函数

**将函数中的形参改为指针可以减少内存空间,而且不会赋值新的副本**

如果一个结构体有很多数据，那么使用函数传递结构体时需要拷贝的字节数量增加。而使用指针只需要拷贝4个字节(32位系统)

### 结构体嵌套结构体

```c++
struct student{
    string name;
    int age;
    int score;
};
struct School{
	int peopleCout;
    student stu[];
};
```

### 结构体中的const使用

当结构体作为函数的形参传递时，使用的是引用传递，那么为了防止在函数内结构体里数据的修改可以使用 常量指针进行限制

```c++
void printStudents(const student *s){
    
}
```

## 9.核心编程

### 1.内存分区模型

- 代码区：存放函数体的二进制代码，由操作系统管理

- 全局区：存放全局变量和静态变量以及常量

- 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等

- 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收

#### 内存四区意义：
不同区域存放的数据，赋予不同的生命周期。

### 程序执行时

编译后生成exe文件，**未执行该程序前**分为两个区域：代码区、全局区

#### 代码区

存放CPU执行的机器指令

代码区是**共享**的，频繁被执行的程序在内存里只需要一份代码

代码区是**只读**的，防止程序意外修改了指令

#### 全局区

全局变量、常量、静态变量

程序结束后由操作系统释放
##### 在全局区内
全局变量、静态变量static关键字、常量(字符串常量、const修饰的全局变量(全局常量))
##### 不在全局区内

局部变量、const修饰的局部变量(局部常量)

#### 栈区

不要返回局部变量的地址，栈区开辟的变量会在函数结束释放

#### 堆区

使用new开辟空间

### new操作符

堆区开辟的数据，手动释放利用操作符`delete`

释放数组时需要加[] `delete[] arr;`

```c++
int * func(){
    //new返回的是 该数据类型的指针
	int *p=new int(10);
    return p;
}
```

