# 游戏资源管理

游戏运行就是一个接一个资源的展示，如何管理好这些展示的资源让游戏能够流畅运行在开发中非常重要。需要在合理的地方调用、加载资源，资源空闲时对其进行卸载以减少内存占用。当内存超出预算可能导致游戏闪退，所以对资源的管理实际就是对内存的优化！

本文争取一文搞懂资源管理。PS：可能和一个视频学完c++差不多(一个视频一个多月)

TODOLIST：

- [ ] 分包策略
- [ ] 依赖处理
- [ ] AssetBundle详细
- [ ] 热更
  - [ ] 断点续传
  - [ ] 代码热更新/热重载
    - [ ] Lua重新将函数指针赋值的策略
    - [ ] HybridCLR
- [ ] 资源包和资源区分开
- [ ] 一些资源策略
  - [ ] 整包只有基础内容，后续章节热更的形式(大资源情况)
- [ ] 扩展YooAsset

## 资源管理主要的需求有哪些？

- 为开发与正式版本提供资源的加载和卸载
- 支持远程更新资源
- 做好版本、平台、渠道的资源管理
- 内存优化

## Unity中的两种加载方式

### Resources

- 资源必选放在Resources文件夹下；有容量上限(大概是2G)；重复加载和重复卸载操作，Unity做了容错处理不会报错。不支持热更，只能打整包
- 适合放游戏的启动逻辑需要的资源
- 可能会延长游戏启动时间

### AssetBundle

- 可以理解成Unity内的资源压缩包，有不同的压缩方式，解压速度和包体大小也不同(LZMA 和 LZ4)。
- 适合做热更，以减少包体的初始大小。
- 已加载的资源不允许重复加载，会报错。而使用AssetDatabase则不需要考虑。需要使用引用计数。

这里还有一些开源的资源管理系统，如YooAsset。

## 同步加载与异步加载

### 同步加载

同步加载在加载资源时，会阻塞线程。等加载逻辑完成后才继续执行后续逻辑（图灵机）

### 异步加载

同步加载在加载较大资源时阻塞明显，造成卡顿。因为Unity中所有的渲染都是放在主线程中的，所以主线程阻塞非常致命不能进行任何玩家操作。

所以需要使用另外一种加载方式对较大资源进行加载。异步加载使用协程/线程进行加载逻辑，等资源加载完毕后触发资源加载后的callback。

在一些资源的加载会影响到游戏的展示时，可以在需要之前对资源进行预先加载，保证流程能够顺利进行。

#### 异步加载的三种状态

异步加载的逻辑由于执行完成的时间不确定，可能会导致其他逻辑的冲突。所以我们给异步加载按照逻辑划分状态，好让其他逻辑能够做区分，不同状态下处理相应的操作。

- 未加载

  异步加载还没开始时可能需要准备的事情，比如资源包不在本地需要下载、解密、解压等等。

- 加载中

  资源开始加载后，其他业务逻辑也加载了相同资源时，可以判断这个资源的状态。正在加载则不再进行加载前的准备操作，并把加载后的callback注册进去。

- 已加载

  主要为加载后触发相应callback。

```c#
  public enum LoaderState
    {
        NONE,           // 默认
        LOADING,        // 加载中
        FINISHED,       // 完成
    }
```

#### 存在问题

玩家在进入一个场景后，假设资源预加载需要10s，玩家却在未加载完资源的过程中退出场景。这时候就会引发资源状态的问题。

## 资源缓存池

资源缓存池为统一存储和调用资源的地方。在加载资源后统一存入池子中，卸载时则将其从池子中删除。

加载时先判断池子中是否存在此资源包，如果已经加载过了直接则直接使用，未加载再进行加载逻辑。

以下内容主要以AssetBundle举例

```cc
public class AssetBundlePool{
	private Dictionary<string,AssetBundleInfo> m_LoadAssetBundle = new Dictionary<string,AssetBundleInfo>();
}
```

## 引用计数

### 基础概念

引用技术的应用范围很广，很多引擎、框架、插件的底层都离不开引用计数。

简单思想：被引用+1，不被引用时-1，当为0时触发清空逻辑。

```c#
public interface IRefCounter
{
    int RefCount { get; }
    void Retain();
    void Release();
}
public class SimpleRC : IRefCounter
{
    public int RefCount { get; private set; }
    public void Retain()
    {
        RefCount++;
    }
    public void Release()
    {
        RefCount--;
        if (RefCount == 0){ OnZeroRef(); }
    }
    protected virtual void OnZeroRef(){}
}

```

### 与资源管理结合的引用计数

资源被使用时引用次数+1，资源解除引用时次数-1，当引用次数为0时则进行卸载逻辑。

```c#
public class AssetBundleInfo
{
    private AssetBundle m_AssetBundle;   //AB包引用
    public AssetBundle AssetBundle { get { return m_AssetBundle; } }
    public int m_ReferencedCount;           //引用计数
    public AssetBundleInfo(AssetBundle assetBundle)
    {
        m_AssetBundle = assetBundle;
        m_ReferencedCount = 1;
    }
}
```

### 与资源缓冲池结合的加载

```c#
public class AssetBundlePool{
	private Dictionary<string,AssetBundleInfo> m_LoadAssetBundle = new Dictionary<string,AssetBundleInfo>();
	  public AssetBundle LoadAssetsFromAB(string abName)
    {
        AssetBundleInfo assetBundleInfo = null;
        if (m_LoadAssetBundle.TryGetValue(abName, out assetBundleInfo))
        {   //检查是否加载过
            assetBundleInfo.m_ReferencedCount++;//这里可以使用封装好的引用计数，为了方便展示直接使用
        }
        else
        {
            string loadPath = PathUnit.DataPath + PathUnit.ABRootPath + abName;
            var ab = AssetBundle.LoadFromFile(loadPath);
            if (ab is null)
            {
                Debug.Log("AB包加载失败！"+ loadPath);
            }
            else
            {
                assetBundleInfo = new AssetBundleInfo(ab);
                m_LoadAssetBundle.Add(abName, assetBundleInfo);
                assetBundleInfo.m_ReferencedCount++;
            }
        }
        return assetBundleInfo.AssetBundle;
    }
}
```

异步加载也是相同的操作，但有点不同。需要一个额外的队列记录加载中的文件。当加载中的文件又收到了加载请求时，则需要在列表中查找是否正在加载。

```c#
public class AssetBundleCachePool
{
    public MonoBehaviour monoBehaviour;
    private Dictionary<string, AssetBundleInfo> m_LoadAssetBundle = new Dictionary<string, AssetBundleInfo>();
    private Dictionary<string, Action<AssetBundle>> m_LoadingAssetBundle = new Dictionary<string, Action<AssetBundle>>();
     public void LoadAssetsFormAbAsync(string abName, Action<AssetBundle> loadingABAction)
    {
        monoBehaviour.StartCoroutine(OnLoadAssetsFormAbAsync(abName, loadingABAction));
    }
    IEnumerator OnLoadAssetsFormAbAsync(string abName, Action<AssetBundle> loadingABAction)
    {
        AssetBundleInfo assetBundleInfo = null;
        if (m_LoadAssetBundle.TryGetValue(abName,out assetBundleInfo))
        {
            Debug.Log("已加载过");
            AssetBundle assetBundle = assetBundleInfo.AssetBundle;
            //引用计数+1
            assetBundleInfo.m_ReferencedCount++;
            //触发回调
            if (loadingABAction != null)
            {
                loadingABAction.Invoke(assetBundle);
            }
            yield break;
        }
        else
        {
            if (m_LoadingAssetBundle.TryGetValue(abName,out Action<AssetBundle> temploadingABAction))
            {
                if (loadingABAction != null) { temploadingABAction += loadingABAction; }
                Debug.Log("正在被加载");
                yield break;
            }
            else
            {
                //这步需要执行，避免与其他逻辑冲突
                m_LoadingAssetBundle.Add(abName, loadingABAction);
                string loadPath = PathUnit.DataPath + PathUnit.ABRootPath + abName;
                AssetBundleCreateRequest assetBundleCreateRequest = AssetBundle.LoadFromFileAsync(loadPath);
                AssetBundle resAB = assetBundleCreateRequest.assetBundle;
                if (resAB is null)
                {
                    Debug.LogError("AB包不能存在");
                }
                else
                {
                    assetBundleInfo = new AssetBundleInfo(resAB);
                    m_LoadAssetBundle.Add(abName, assetBundleInfo);
                }
                //加载完成移除加载中列表
                //避免啥异常状况，保险点！先判断是否存在
                if (m_LoadingAssetBundle.ContainsKey(abName))
                {
                    Action<AssetBundle> action = m_LoadingAssetBundle[abName];
                    m_LoadingAssetBundle.Remove(abName);
                    var callBackList =  action.GetInvocationList();
                    foreach (Action<AssetBundle> callBack in callBackList)
                    {
                        callBack.Invoke(resAB);
                    }
                }
            }
        }
    }
}
```

### 与资源缓冲池结合的卸载

## 依赖

一个资源身上用到了别的AB包中的资源，这时候如果只加载自身的AB包，就会出现资源丢失的情况。这时候就需要把当前资源需要用到的依赖包一起加载出来。

但是我们又要怎么知道这个资源依赖于哪些包？

这时候就需要用到Unity提供的AB包依赖文件来判断，后缀`.manifest·`。

## AssetBundle篇

Todo:sassy_woman:这部分以前的笔记找不到了，先欠着。

## 热更篇

Todo:sassy_woman:这部分内容写在别的地方，比较乱后续整理。