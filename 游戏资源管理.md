# 游戏资源管理

游戏运行就是一个接一个资源的展示，如何管理好这些展示的资源让系统能够流畅运行也是件比较繁琐的事情。需要在合理的地方调用、加载资源，资源空闲时对其进行卸载以减少内存占用。当内存超出预算可能导致游戏闪退，所以对资源的管理实际就是对内存的优化！

## 资源管理主要的需求有哪些？

- 为开发与正式版本提供资源的加载和卸载
- 支持远程更新资源
- 做好版本、平台、渠道的资源管理
- 内存优化

## Unity中的两种加载方式

### Resources

- 资源必选放在Resources文件夹下；有容量上限(大概是2G)；重复加载和重复卸载操作，Unity做了容错处理不会报错。不支持热更，只能打整包
- 适合放游戏的启动逻辑需要的资源
- 可能会延长游戏启动时间

### AssetBundle

- 可以理解成Unity内的资源压缩包，有不同的压缩方式，解压速度和包体大小也不同(LZMA 和 LZ4)。
- 适合做热更，以减少包体的初始大小。
- 已加载的资源不允许重复加载，会报错。而使用AssetDatabase则不需要考虑。需要使用引用计数。

这里还有一些开源的资源管理系统，如YooAsset。

## 同步加载与异步加载

### 同步加载

同步加载在加载资源时，会阻塞线程。等加载逻辑完成后才继续执行后续逻辑（图灵机）

### 异步加载

同步加载在加载较大资源时阻塞明显，造成卡顿。在Unity中所有的渲染都是放在主线程中的，主线程阻塞玩家就无法操作了。

所以需要使用另外一种加载方式对较大资源进行加载。异步加载使用协程/线程进行加载逻辑，等资源加载完毕后触发资源加载后的callback。

#### 存在问题

玩家在进入一个场景后，假设资源预加载需要10s，玩家却在未加载完资源的过程中退出场景。这时候就会引发资源状态的问题。

## 资源缓存池

资源缓存池为统一存储和调用资源的地方。在加载资源后统一存入池子中，卸载时则将其从池子中删除。

加载时先判断池子中是否存在此资源包，如果已经加载过了直接则直接使用，未加载再进行加载逻辑。

```cc
public class AssetBundlePool{
	private Dictionary<string,AssetBundleInfo> m_LoadAssetBundle = new Dictionary<string,AssetBundleInfo>();
}
```



## 引用计数

引用技术的应用范围很广，很多引擎、框架、插件的底层都离不开引用计数。

简单思想：被引用+1，不被引用时-1，当为0时触发清空逻辑。

```c#
public interface IRefCounter
{
    int RefCount { get; }
    void Retain(object refOwner = null);
    void Release(object refOwner = null);
}
public class SimpleRC : IRefCounter
{
    public int RefCount { get; private set; }
    public void Retain(object refOwner = null)
    {
        RefCount++;
    }
    public void Release(object refOwner = null)
    {
        RefCount--;
        if (RefCount == 0){ OnZeroRef(); }
    }
    protected virtual void OnZeroRef(){}
}

```

### 与资源管理结合的引用计数

资源被使用时引用次数+1，资源被弃用时引用次数-1，当引用次数为0时则进行卸载逻辑。

```c#
public class AssetBundleInfo{
  public AssetBundle m_AssetBundle;	//AB包引用
  public int m_ReferencedCount;			//引用计数
  public AssetBundleInfo(AssetBundle assetBundle){
    m_AssetBundle = assetBundle;
    m_ReferencedCount = 1;
  }
}
```

### 与资源缓冲池结合

```c#
public class AssetBundlePool{
	private Dictionary<string,AssetBundleInfo> m_LoadAssetBundle = new Dictionary<string,AssetBundleInfo>();
  public AssetBundle LoadAssetsFromAB(string abName){
    AssetBundleInfo assetBundleInfo = null;
    if(m_LoadAssetBundle.TryGetValue(abName,out assetBundleInfo)){	//检查是否加载过
      assetBundleInfo.m_ReferencedCount++;//这里可以扩展方法
    }
    else{
      string loadPath = PathUnit.DataPath + PathUnit.ABRootPath + abName;
      var ab = AssetBundle.LoadFromFile(loadPath);
      if(ab is null){
      	Log.Error("AB包加载失败！",loadPath);
      }else{
        assetBundleInfo = new AssetBundleInfo(ab);
        m_LoadAssetBundle.Add(abName,assetBundleInfo);
      }
    }
  }
}
```

异步加载也是相同的操作，但有点不同。需要一个额外的队列记录加载中的文件。当加载中的文件又收到了加载请求时，则需要在列表中查找是否正在加载。

## AssetBundle篇

Todo:sassy_woman:这部分以前的笔记找不到了，先欠着。



