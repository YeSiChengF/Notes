# 游戏资源管理

资源管理我认为涉及的内容非常的广泛，基本涵盖游戏中的资产(音频、图片、代码、预制体等等)。需要在合理的地方调用、加载资源，资源空闲时对其进行卸载以减少内存占用。当内存超出预算可能导致游戏闪退，所以对资源的管理实际就是对内存的优化！

## 资源管理主要的需求有哪些？

- 为开发与正式版本提供资源的加载和卸载
- 支持远程更新资源
- 做好版本、平台、渠道的资源管理
- 内存优化

## Unity中的两种加载方式

### Resources

- 资源必选放在Resources文件夹下；有容量上限(大概是2G)；重复加载和重复卸载操作，Unity做了容错处理不会报错。不支持热更，只能打整包
- 适合放游戏的启动逻辑需要的资源
- 可能会延长游戏启动时间

### AssetBundle

- 可以理解成Unity内的资源压缩包，有不同的压缩方式，解压速度和包体大小也不同(LZMA 和 LZ4)。
- 适合做热更，以减少包体的初始大小。

这里还有一些开源的资源管理系统，如YooAsset。

## 同步加载与异步加载

### 同步加载

同步加载在加载资源时，会阻塞线程。等加载逻辑完成后才继续执行后续逻辑（图灵机）

### 异步加载

同步加载在加载较大资源时阻塞明显，造成卡顿。在Unity中所有的渲染都是放在主线程中的，主线程阻塞玩家就无法操作了。

所以需要使用另外一种加载方式对较大资源进行加载。异步加载使用协程/线程进行加载逻辑，等资源加载完毕后触发资源加载后的callback。

#### 存在问题

玩家在进入一个场景后，假设资源预加载需要10s，玩家却在未加载完资源的过程中退出场景。这时候就会引发资源状态的问题。

## 引用计数

引用技术的应用范围很广，很多引擎、框架、插件的底层都离不开引用计数。

简单思想：被引用+1，不被引用时-1，当为0时触发清空逻辑。

```c#
public interface IRefCounter
{
    int RefCount { get; }
    void Retain(object refOwner = null);
    void Release(object refOwner = null);
}
public class SimpleRC : IRefCounter
{
    public int RefCount { get; private set; }
    public void Retain(object refOwner = null)
    {
        RefCount++;
    }
    public void Release(object refOwner = null)
    {
        RefCount--;
        if (RefCount == 0){ OnZeroRef(); }
    }
    protected virtual void OnZeroRef(){}
}

```

### 与资源管理结合的引用计数



## AssetBundle篇



