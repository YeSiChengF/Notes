# Unity高级编程：主程手记

## 网络通讯

###  TCP与UDP

#### TCP

##### TCP建立连接要求进行三次握手，断开连接进行四次握手

###### 三次握手建立连接：
1.A向B发送连接请求。
2.B向A发送同意连接，并要求同步数据包
3.A向B发送一个数据包，确认B的数据同步要求

###### 四次握手断开连接：
1.A完成数据传输后，将控制位FIN置1，提出停止TCP连接的请求
2.B收到FIN位置上的1信息后对其作出响应，确认这一方向上的TCP连接将关闭，将ACK置1
3.B再提出反方向的关闭请求，并将控制位FIN置1，发送给A，并关闭连接。
4.A对B的请求进行确认，将ACK置1，并关闭连接。

####### ACK：TCP报头的控制位之一，对数据进行确认，确认有目标端发出，通过目标端告诉发送端，这个序列号之前的的数据段都收到了。比如，确认号为X，则表示前X-1个数据段都收到了。只有当ACK=1时确认号才有效；当ACK=0时，确认号无效，这时会要求重传数据，以保证数据的完整性。

####### SYN：同步序列号，TCP 建立连接时将这个位置 1。

####### FIN：发送端完成发送任务位，当 TCP 完成致据传输需要断开时，提出断开连接的一方将该位置 1。

###### TCP采用面向连接的通信方式，打打提高数据通信的可靠性，正式传输前有了交互，为数据正式传输打下可靠基础。

##### TCP包头结构

###### 源端口 (source port)16位。

###### 目标端口 (target port)16位。

###### 序列号(SYN) 32 位

###### 回应序号 (ACK)32位

###### TCP 头长度 (head size) 4 位

###### 保留 (reserved）6 位。

###### 控制代码 6位

###### 窗口大小 (size)16位。

###### 偏移量 16位。

###### 校验和 16位

###### 选项 32位（可选)。

###### 这样，我们把它们需要的空间位数相加得出 TCP 包头的最小长度共为 （192-32）位。最后 32 位的选项位可没有，所以最小长度为（160/8）字节=20 字节。

##### TCP通过滑动窗口的概念来进行流量控制。若发送端发送数据的速度很快，而接收端的接受速度却很慢，就很难保证数据不丢失，所以需要进行流量控制，协调好通信双方的工作节奏。

##### 滑动窗口可以理解成接收端能提供的缓冲区大小是有限且变化的。TCP 利用滑动的窗口值来告诉发送端对它所发送的数据能提供多大的缓冲区，以此来协调控制两边的传送节奏和速率。由于窗口只有16位，所以接收端 TCP 最大能提供65535 字节的缓冲

#### UDP

##### 特点

###### 1.非连接协议，传输数据之前，源端和终端不建立连接，当想传送时，就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP 把每个消息段放在队列中，应用程序每次从队列中读一个消息段。

###### 2.由于传输数据不建立连接，因此不需要维护连接状态，包括收发状态等。一台服务机可同时向多个客户机传输相同的消息。

###### 3.UDP 信息包的包头很短，只有8字节，相对于TCP 的20 字节包头信息，UDP 的包头开销很小。

###### 4.吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。

###### 5.UDP 会尽最大努力去传输和接受数据且没有限制，但并不保证可靠的数据交付，主机也不需要维持复杂的链接状态表（里面有许多参数）。

###### 6.UDP 是面向报文的。发送方的 UDP 对应用程序传过来的报文，在添加包头后就向下交付给IP层。既不拆分，也不合并，而只是保留这些报文的边界，因此，应用程序需要
自己限制合适的报文大小，以免报文太大导致丢失率高。

##### UDP包头结构

###### 源端口 16位

###### 目的端口 16位。

###### 长度16位。

###### 校验和 16位。

###### 包头总共 64位，即8字节。包头后的数据长度由长度字段决定 最大能提供65535 字节

### TCP和UDP的对比

#### 不同之处

##### TCP是基于连接，UDP是面向无连接的

##### 对系统资源开销，TCP开销较多，UDP开销少

##### TCP包头大，且有各类状态，底层程序结构稍显复杂；UDP包头小，没有状态，程序结构较简单。

##### TCP为流模式，UDP为数据报模式

##### TCP可保证数据的正确性(TCP会校验)，UDP可能会丢包

##### TCP确保数据的顺序，UDP无法保证

#### TCP能确保数据到达，有确认机制，并且数据到达后是有序的，数据报的大小没有限制，不需要自己切分数据报(会造成沾包和分包情况)，底层会进行数据报切分。
UDP是基于数据包构建，意味着在某些方面需要颠覆在TCP下的概念。

#### UDP只使用一个Socket进行连接，不像TCP需要为每个客户端建立一个Socket连接。

#### TCP容易造成巨大的延迟问题。在发生丢包的时候，会产生巨大的延迟，因为TCP首先会去检测哪些包发生了丢失，然后重发所有的包，直到它们都被接收到为止。
虽然UDP也会有延迟，但是可以通过多种方法减少延迟(因为UDP可以扩展)，不像TCP所有东西都依赖于TCP协议本身和无法被改变。

### C#实现TCP

#### 需要考虑的方面

##### 建立连接

##### 断线检测

##### 网络协议

##### 发送和接收队列缓冲

##### 发送数据合并

##### 线程死锁策略

#### TCP的API库

##### BeginConnect：开始连接

##### BeginReceive：开始接收信息

##### BeginSend：开始发送数据

##### BeginDisconnect：开始断开

##### Disconnect：立刻断开连接

##### 前四个都是异步的，调用后会开启一个线程来工作，最后一个为同步阻塞方式的断开连接接口。
最后一个阻塞式接口大多在游戏退出时调用，但是APP没有退出时间。因此多被用在UnityEditor或Windows版本上调用。

#### 线程锁

##### 当主线程与子线程一起工作到都需要某个内存块或者资源的某时间点时，就会同时去读取和写入资源，就会造成资源读/写混乱的情况。
因此在所有线程上，当调用有冲突的资源时，都需要执行锁的操作，以防止线程在读取或写入操作时对资源进行错误的争夺而造成脏数据的情况。

#### 缓冲队列(需要实现的原因)

##### 程序还没处理好当前的数据，就有许多数据包已经从服务端传送到了客户端。发送数据时也是一样，会瞬间积累很多需要发送的数据包。这些数据包如果没有被保存好，则无法进行重发，甚至会丢失，所以需要一个队列来进行存储和缓冲，这个队列被称为缓冲队列。

##### TCP自带数据包的校验和重发功能，因此保存数据包主要为了在断线重连时能重发数据包，因为传统的TCP在断线时数据缓冲中的数据会丢失，从而重连时无法针对没有发送出去的数据包进行重发。

##### 发送的数据包队列相对简单，不需要应对多线程问题。
接收数据包的缓冲队列，一般让负责接收的子线程将收到的数据包放入接收缓冲队列，再让主线程通过Update进行轮询检查接收队列内是否有数据包，有则一个个取出，没有则继续进行轮询。

#### 双队列实现

##### 缓冲队列虽然是多线程编程常用手段之一，但是效率并不够高，多个线程会因为锁的效率影响而被锁点卡住，导致其他线程无法继续工作。

##### 双队列数据结构能够很好解决多线程的锁问题，各线程能调用各自的队列而不用因为线程锁等待，进而提升多线程中队列的读/写效率

##### 接收数据线程接收到数据时直接推入接收数据的队列中，区别在于处理数据的线程轮询时，会先将接收数据的队列复制到处理数据的队列中，并清空接收数据的队列，然后主线程会对复制后的数据队列进行处理，这时子线程无需等待主线程的逻辑处理时间就能够顺利地继续接收数据。
将缓冲队列的概念分为接收数据队列和处理数据队列的概念。

##### 伪代码实现

###### //子线程中的接收数据线程
void Receive_callBack(Data _result)
{
	PushData(_result)
}
//处理数据的主线程
void SwitchQueue()
{
	lock(obj)
	{
		Swap(receiveQueue,produceQueue);
	}
}
void Update()
{
	SwitchQueue();
	while((data=PopQueue())!=null)
	{
		Deal_with_network_data(data);
	}
}

####### 接收时逻辑与缓冲队列相同。不同在于主线程处理逻辑时，先切换队列，防止对队列占用过多，切换完毕后在对队列中的全部数据进行处理。

####### 这样两个线程在锁上的时间就变短了，原本在处理期间全部上锁而导致其他线程无法使用，现在只需要在切换一瞬间上锁资源即可，大大提高多线程工作效率。

#### 发送数据

##### 问题：
发送数据时也需要队列来缓冲。发送数据包很多时，也有可能很短时间内会积累过多数据包而导致发送池溢出。
数据包小但是量大时，每次发送再等待接收后发送下一个就会导致发送效率过低。
数据包大时，容易发送失败或丢包。TCP会全盘否定发送的内容，并将整个包重新发送，效率极其低。

##### 需要对发送也建立发送缓冲来保证发送的有序和高效。

###### 1.每次调用发送接口时，先将数据包推入发送队列，发送程序就开始轮询是否有需要发送的信息在队列里，有就发送，没有就继续轮序。

###### 2.发送时合并队列里的一部分数据包(一个包可为设定大小)，这样可以一次性发送多个数据包，以提高效率。

###### 3.对合并操作进行限制，如果因为合并而导致数据包太大，也会导致效率太低。合并数据的大小应限制在窗口大小范围内(2的16次方字节内)。

#### 协议数据定义标准

##### 协议定制的关键点

###### 1.选择客户端和服务端都能接收的格式

###### 2.数据包最小化

####### 不能对于压缩算法过度依赖，而不考虑协议本身的问题。

###### 3.要有一定的校验能力

####### 包头来作为业务层的协议格式，通常为4~8字节组成，包含数据大小、加密方式、广播方式等。
较为重要的为数据包大小，如果接受到的数据块不满足大小，则需要继续等待。
(复杂点把数据块的标识也融入头部中，每个标识为一个2字节的正整数，为了确定调用的是那个逻辑句柄，可把数据包分为头、固定标识信息、数据块三部分。头部存储包含大小、加密位、广播方式等信息，标识信息则存储例如句柄编号、序列号、特殊命令编号、校验码等标识信息。数据块存储具体的数据信息)

####### MD5校验

######## 数据块使用MD5散列函数生成一个校验字符串，将检验字符串保存在数据包中。服务端收到数据包时进行同样的MD5操作，比对校验字符串是否一致。

####### 奇偶校验

######## 与MD5类似，只是使用的函数方法不同。将每个数据进行“异或”赋值成一个变量，并保存于数据包中。服务端进行同样操作，对数据包中的校验值进行比较。

####### 循环冗余校验(CRC)

######## 利用除法及余数的原理进行错误检测，并将收到的数据进行除法运算，如果能除尽说明数据校验通过，如果不能除尽，则表明数据被篡改过。

######## 算法步骤

######### 1.前后端约定一个除数

######### 2.将数据块用除法取余

######### 3.将余数保存在数据包中

######### 4.服务器收到数据后，将余数和数据块相加，并进行取余操作。

######### 5.若余数为0，则认为校验正常，否则认为数据篡改过。

###### 4.加密

####### 保证数据包不给篡改和查看需要对数据包主体进行加密。加密算法有RSA、公钥私钥及非对称加密等。最简单最快速的就是对数据进行“异或”处理，两次异或让数据回到原形，发送时对数据进行一次“异或”处理，收到时再进行一次“异或”处理。

####### 密钥

######## 密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。

######## 密钥常常暴露在外界，导致可以在客户端破解和查看，了解网络数据协议的格式而进行一些破坏，所以前后端使用同一个密钥会比较危险。
非对称加密比较安全，前后端密钥不同，且各自保存，及时前端密钥泄露也可以随时替换。

######## 无法避免前端的密钥暴露在外面被人破解，比如把密钥分为几段，分别用几种方式隐藏在项目文件中，用多种加密方式对密钥加密，在关键密钥被获取前再做加密等。

######## 如果加密的性能损耗太大则得不偿失，加密的过程需要是快速的，在不损耗大量CPU的前提下、不影响项目性能的情况下对协议数据做最大化的加密。

#### 断线检测

##### TCP自身的断线检测机制不够好，时常因为网络问题导致断线的判断不够及时，所以需要加强断线检测机制，让断线判断更加准确。

##### 心跳包协议

###### 每几秒服务器向客户端发送一个心跳包，包含服务器时间、服务器状态等少量信息，然后由接收到这个心跳协议的客户端进行反馈，发送给服务端一个心跳回应包，包含客户端少量信息，如客户端状态、用户信息等。

###### 服务端在一定时间没收到心跳包信息时，认为客户端已经断线，这时主动断开客户端连接。
客户端也是相同逻辑，一定时间没收到任何数据包则认为网络已经断开，客户端最好主动退出游戏、重新登陆、或断线重连。

### C#实现UDP

#### 连接确认机制

##### UDP是无状态连接，没有三次握手协议，如果网络异常没有连接上会导致收发失败。
发送和接收如果建立在连接确认的基础上，会更加牢固

##### 1.如何确认连接成功

###### 通过模仿TCP的确认连接机制，可以改为两次握手

###### 首先在UDP打开连接后，在确认连接前不进行任何其他类型的数据发送和接收，将用来确认连接成功与否的数据包称为握手数据包。

###### 打开连接后，客户端向服务端发送一个握手数据包，代表请求连接，数据包内数据仅仅是一个序列号Seq=0，或者不是序列号可以是特殊字段。

###### 服务端收到第一次握手数据包后，向客户端反馈一个握手数据包，同样包含能识别的确认信号。自此确认连接建立。

###### 伪代码实现

####### 1.API建立UDP连接
SvrEndPoint = new IPEndPoint(IPAddress,Parse(host),port);
UdpClient = new UdpClient(host,port);
UdpClient.Connect(SvrEndPoint);

####### 2.启动接收数据线程
UdpClient.BeginReceive(ReceiveCallback,this);
void ReceiveCallback(IAsyncResult ar)
{
	Byte[] data=(mIPEndPoint == null) ?
		UdpClient.Receive(ref mIPEndPoint):
		UdpClient.EndReceive(ar,ref mIPEndPoint);
	if(null != data)
		OnData(data);
	if(mUdpClient != null)
	{
		//尝试接收信息
		mUdpClient.BeginReceive(ReceiveCallback,this);
	}
}
//UDP打开连接后可以立即开始接收数据的接口并开启线程

####### 3.发送连接确认数据包，并屏蔽其他发送和接收功能
SendConnectRequest();
StopSendNormalPackage();
StopReceiveNormalPackage();

####### 4.等待接收连接确认数据包
void OnData(byte[] data)
{
	if(!IsConnected)
	{
		if(IsConnectResponse(data))
		{
			OnEvent(Event.ConnectSuccess);
			IsConnected=true;
		}
		return;
	}	
	ProcessNormalData(data);
}
//接收到数据的处理过程，先判断当前是否处于连接状态，再判断该数据包是否是握手数据包，如果是握手数据包证明服务端接收到了握手数据包并做出了回应，可以标记为连接状态。

####### 5.建立连接后开始正常发送和接收数据包，包括识别、装载、推入队列、检测是否丢失、是否需要重发等。
void ProcessNormalData(data)
{
	if(!IsConnected) return;
	DealNetworkData(data);
}

##### 2.检测连接是否依然存在

###### UDP可以使用和TCP一样的方法(心跳机制)来确认连接状态，并准确确认连接方式。不过不像握手数据包一样单一。
客户端间隔x秒发送一个心跳数据包给服务端，数据包里包含客户端信息，包含ID、角色状态、设备信息，包不能太大否则会增加宽带负担。
服务端收到时也回应一个心跳数据包，包含服务器时间、服务器当前状态等。

###### 过了间隔时间未收到心跳数据包客户度开始重连机制

####### 1.每个x秒向服务端发送数据包

####### 2.服务端收到心跳数据包后进行回应心跳数据包

####### 3.客户端和服务端超过间隔时间没收到心跳包判断连接断开

####### 4.当判定连接断开或主动断开连接，客户端提示用户、或重新创建连接。

#### 数据包校验与重发机制

##### UDP相当于TCP的缩减版，缩减了校验和重发机制。需要额外增加对数据的校验和重发机制来确保数据的可靠性。

##### 校验和重发机制

###### Seq(Sequence Number)源端的发送序列号；ACK(Acknowledgement Number)目的端的接收确认序列号。

###### 校验机制

####### 1.A端向B端发送数据包，TCP包头包含字段Seq的序列号值为（已发送数据包的累计大小）。

####### 2.B端收到了发送的数据包后，于是向A端发送确认包，确认包包含ACK （为接收到的数据包大小）

####### 3.A端收到B端的确认数据包后，检测累计发送大小和累计接收大小是否一致，如果不一致，则认为传输错误，启动重传机制，退回到最后一次正确的数据包位置进行重传，确保可靠性。

####### 4.如果大小比较一致，则认为B端准确收到了A端的数据包，则继续发送，否则启动重传机制。

####### 5.B端向A端发送也是同样方法和步骤。

###### 序列号确认传输机制是TCP可靠传输的保障，除了累积接收大小和累积发送大小的比较外，若在规定时间内收到确认数据包，则表明该报文发送成功，继续发送下个报文。如果超过时间则启动重传。

###### TCP一旦传输失败，便重传整个数据即便是已到达的数据也要重传，UDP可进行改进

####### 1.A端发送给B端数据包，包内包含Seq=1(表示数据包的发送序列)，发送后将此数据包推入已发送但还没确认的队列中。
B端收到给A端回应一个ACK=1的包，表示Seq=1的包已经收到。
x秒后若没收到Seq=1的包则从发送但还没确认的队列中取出，重新发送。

####### 2.A端发送给B端x个数据包，Seq的序列号是连续的，在过程中中间某些数据包丢包情况
A端等待确认数据包超时后，对丢包的数据包进行重传。
B端收到数据包后，处理数据包时，发现数据包顺序有跳跃现象，表示数据包丢失，等待A端重传。在断开的序列处停止处理数据包，等待重传数据包到来。

####### 3.B端可以做加快重传确认时间的处理。当处理数据包时，发现顺序中断时，立即向A端发送确认包要求启动丢包的数据包的重传，这样加快了丢包重传的确认速度。

#### 丢包问题分析

##### 1.接收端处理时间过长导致丢包

###### 异步方法接收数据时，处理完数据后才能再调用接收方法，如果处理数据过程中发过来的包有可能丢失。
解决方案：在收到一个包后，最短时间内回到监听状态，期间避免复杂操作。
将接收到的包放入缓冲区，并迅速回到监听状态或者用双队列缓冲处理。

##### 2.发送到数据包大，导致丢包概率加大

###### 数据包如果超过接收者缓存，大概率会导致丢包，一般当包超过MTU大小数倍时，会增大丢包概率。
MTU：网络上传输的最大数据包，大部分网络设备是1500byte，本机MTU比网关MTU大时，就会拆开传送，产生数据包碎片，增加丢包率，从而增大重发概率，网速变慢。
报文长度最好控制在1280byte一下。

##### 3.发送包的频率太快

###### 频率太快中间不休眠，也有可能导致丢包。
通过建立Socket接收缓冲队列或发送缓冲队列解决，发送频率过快时考虑通过线程Sleep休眠作为时间间隔。
UDP的发送是异步的，直到数据完全发送才会返回调用函数，UDP并不保证当执行到下一条语句时前面的数据已被发送。

### 封装HTTP

#### HTTP协议原理

##### 短连接，平均连接时间短，不受前端控制。

##### Unity的WWW对.NET中的Http库API做了协程的封装(unity2018后被UnityWebRequese取代)，.Net库直接使用线程，需要关注主线程和子线程资源抢占情况。

##### HTTP是请求/响应协议，一个请求只有一个相应。

##### HTTP是应用层协议，所以要求底层传输层协议是可靠的，因此HTTP依赖于面向连接的TCP协议进行消息传递。HTTP本身没有检测连接、数据是否传输准确、是否有数据到达的机制。HTTP只是在TCP的基础上制定规则。

##### HTTP协议格式

###### HTTP两种参数请求方式

####### GET

######## 把参数值以Key-Value的键值对形式放在地址中传输给服务器

######## ？Key1=Value1&Key2=Value2...

######## ?开头

######## 必须以字符串形式明文显性的展示在地址上

######## GET/root1/module?name1=value1&name2=value2 HTTP/1.1
Host : localhost : 8080
Accept-Language : fr
//这里HEAD和BODY用空行隔开
body content

####### POST

######## 和GET实质一样(格式)，并把

######## 把参数值放在协议数据包中，POST可以使用二进制作为参数值，并且存放在Body中，body content主要存储请求内容。

######## POST/root1/module.php HTTP/1.1
Host : localhost : 8080

name1=value1&name2=value2

###### 服务器在收到客户端请求处理后的响应数据

####### HTTP:1.1 200
Date:Mon , 31Dec200104 : 25 : 57GMT
Server:Apache/1.3.14(Unix)
Content-type:text/html
Last-modified:Tue,17Apr200106:46:28GMT
Content-length:xxx

body content

####### 200表示请求成功状态码，404找不到网页，500表示服务器程序报错，400表示访问请求参数错误，403表示被拒绝访问

##### HTTP1.0、HTTP1.1、HTTP2.0描述

###### HTTP1.0

####### 一个请求就独占一条TCP连接，并行获取多个资源就要建立多条连接

###### HTTP1.1

####### 常用的协议

####### 兼容了HTTP1.0，给同一个地址不同的host增加了cache特性，增加了Chunked transfer-coding标志切割数据块

####### 在应答回来前按顺序发送多个请求，服务端按照请求顺序发送应答。

####### 队首阻塞问题：后面的请求处理完了，也必须等待前面的应答发送完毕，才能发送后面的应答。

###### HTTP2.0

####### 不能兼容HTTP1.0、1.1，被应用于HTTPS上，1.0、1.1运用在原有HTTP上

####### 引入Stream概念，一个TCP连接可以被多个Stream共享，每个Stream上都可以运行单独的请求和应答，从而实现TCP连接的复用。一个TCP连接可以传输多个请求和应答数据。

####### 使用二进制协议，减少开销。支持服务端主动推送。
流量控制，引入流的优先级和依赖关系。

###### HTTP1.0、1.1使用文本形式的协议，所有数据都以字符串形式存在，会导致协议传输和解析效率不高。
可以通过压缩来减少数据的传输量，但是协议头无法压缩。
body内容少的，协议头可能会成为传输瓶颈。

###### HTTP无连接状态

####### 事务处理没有记忆力，前后两次请求没有相关性可以是不同的连接。服务端处理HTTP请求时，只关注这个连接请求可获取的数据。

####### HTTP请求由软硬件做负载均衡，两次同样地址的请求，有可能处理请求的服务器不同。

###### HTTP每次请求访问结束都有可能断开连接

####### HTTP1.0和1.1根据Content-Length标记来断开连接(为HEAD上的标记，表示body的长度)。客户端依据这个长度接收服务端的数据，会主动进行四次挥手断开连接。
如果没有Content-Length标签，会一直接收服务端数据直到服务端断开连接。

####### HTTP1.1在断开规则上新增Transfer-encoding标记
Transfer-encoding为chunked，则表示body是流式输出，body会被分为多个块，每块的开始标识出当前块的长度，body不需要被Content-Length标识。根据每块长度，判断接收完毕后断开连接。

####### 使用HTTP协议又不断开连接的方式，使用HEADS里的Keep-Alive标识。Keep-Alive让客户端和服务端保持连接状态，指导服务器发现空闲时间结束而断开连接为止。
在Keep-Alive规定时间内仍能发送数据。可以减少三次握手建立连接以及四次挥手断开连接的消耗。
Keep-Alive在使用起来也会有些许限制，比如需要记录发送的数据以防服务端已经断开连接未通知到客户端，或者网络延迟导致发送请求无法到达，或者保持了长时间连接的TCP无意义占用消耗资源。
所以Keep-Alive很少用到游戏项目中。

##### 在Unity3D中HTTP的封装

###### UnityWebRequest代替了WWW类，API修改但是功能一致

###### UnityWebRequest不支持的HEAD标记

####### accept-charst：告诉服务器，客户端采用的编码格式

####### access-control-request-headers：预检请求中，通知服务端在真正请求中采用哪些请求首部。

####### access-control-request-method：预检请求中，通知服务端在真正请求中用哪些HTTP方法

####### connection：处理完这次请求是断开连接还是保持连接

####### date：当前时间值

####### dnt：Do Not Task的简写。表示用户对网络追踪的偏好

####### expect：请求消息头，包含一个期望条件，表示服务端只有在满足此期望条件情况下才能妥善处理请求。
服务端开始检查请求消息头，可能返回一个状态码为100的回复告知客户端继续发送消息体，
也可能返回状态码为417的回复告知对方，要求不能满足。

####### host：请求头指明服务器的域名，以及服务器监听的TCP端口号。

####### Keep-Alive：允许消息发送者暗示连接的状态，还可以用来设置超时时长和最大请求数。

####### origin：指明此次请求发起者来自哪个站点

####### referer：表示当前页面是通过此来源页面里的连接进入的，与origin雷士

####### te：指定用户代理希望用的传输编码类型

####### trailer：允许发送方在分块发送的消息后面添加额外的元信息

####### transfer-encoding：指明将entity安全传递给用户采用的编码形式。一个多节点连接中的每一段都可以应用不同的tranfer-encoding值

####### upgrade：升级为其他协议

####### via：代理服务器相关的信息

####### 因为不支持connection和Keep-Alive所以无法用UnityWebRequest来实现一次连接发送多次数据。

####### content-length不能自定义设置，由API自动设置

###### 使用UnityWebRequest发送和响应请求

####### 请求需要的接口

######## POST(以POST方式发送数据)

######### UnityWebRequest.Post(string url,WWWForm postData)静态函数

######## GET(以GET方式发送数据)

######### UnityWebRequest.Get(string url)静态函数

######## HEAD(修改某个HEAD标签值)

######### UnityWebRequest.SetRequestHeader(string name,string value)非静态函数

######## Start(开始发送请求)

######### UnityWebRequest.SendWebRequest()非静态函数

###### 多次请求时连续发送HTTP请求引起的问题

####### 连续多次发出HTTP请求时，会同时触发多个线程向服务器执行请求操作，每个请求都包含建立连接、发送数据、接收数据、关闭连接的步骤。
多连接可能导致接收数据时顺序无法确定。

####### 解决方案1：多连接同时发起请求，等待所有数据到齐后再调用执行逻辑

####### 解决方案2：逐个发起请求，保证顺序

####### 解决方案3：多连接与逐个发送混合使用

####### 解决方案4：合并请求，并逐个发送合并后的请求包

### 网络数据协议原理

#### JSON

##### 类似于XML但比XML更小、更快、更易解析(不需要结束标签)

##### 轻量级的文本数据交换格式，由字符串组成，独立于语言，具有自由描述性。

##### HTTP协议中还定义了MIME类型，方便终端逻辑识别，Json的MIME类型是application/json，用来描述消息内容类型的因特网标准。
其他MIME消息包含文本、图像、音频、视频等其他软件专用数据

##### JSON解析器比较多，也可以自己实现，制作时多考虑效率和性能方面

#### 自定义二进制数据流协议格式

##### 协议格式分为三部分

###### 数据大小

###### 协议编号

###### 具体数据

##### 自定义格式最不通用，但是可以是最省流量的协议。

##### 在协议迭代或者更换协议有较大改动时，可以增加版本号，根据版本号判断协议如何处理

#### MessagePack

##### 介于JSON和自定义二进制数据流之间的协议

###### It's like JSON,but fast and small

##### 采用Key-Value形式的Map映射类型
与JSON不同处：使用byte形式存储data部分数据(整数、浮点数、布尔值等)
在Map映射范围外加入更多独立(非Key-Vale)数据类型，其中包括自定义二进制数据流的数据类型。

##### key仍使用字符串，逃脱不了字符串占用存储的弊端。

#### potobuf

##### 与语言无关、与平台无关、可扩展的序列化结构数据格式。

##### 标签值小的越先被序列化，标签值1到15的字段序列化时，标签值和类型信息占1个字节。16到2047时占两个字节。

##### import关键字导入其他.proto文件内的内容

###### import "myproject/Person.proto"

##### 限定符规则

###### required表示字段为必要字段。

####### potobuf3取消

###### optional表示字段为可选字段。

####### potobuf3取消

###### repeate限定符表示字段可以包含0个和多个重复的数据，数组类型。可以不赋值

##### 序列化和反序列化

###### 使用标签值来作为键值与变量映射的连接桥梁。

###### 在程序中写死变量对应的标签号，通过工具生成对应代码来减少工作量。

###### 二进制流格式规则

####### 标签号+类型号|数据大小|具体数据

##### 更改数据结构后的兼容问题

###### 消息格式因为需求变更，客户端没更新任然需要可以使用的情况。

###### 1.不要修改已经存在字段的标签号

###### 2.任何新添加的字段必须使用optional和repeated限定符，保证在旧数据无法加入新字段的情况下还能顺利解析。

###### 3.在原有消息中，不能移除已存在的required字段。其他字段可以移除，但是标签号必须保留不能被新的字段重用(弃用不用的意思)。

###### 4.如果需要修改原有字段的类型，为了保证兼容性，只能修改为原有类型兼容的类型。

####### int32、uint32、int64、uint64和bool类型兼容

####### string和byte兼容

####### fixed32和sfixed32与fixed64和sfixed64兼容

##### 优点

###### 用整数(标签值)代替key来映射变量，全程使用二进制数据流更小更快

####### sint32和sint64兼容

###### 随意创建.proto文件，使用代码生成工具生成protobuf代码。

##### 不足

###### 功能简单无法表示复杂的数据概念

###### protobuf目前只运用在数据传输和存储上，其他领域较少

###### xml和json有自解性，可以直接读取和编辑。
protobuf依赖于.proto文件定义，否则无法直接读取出任何内容。

### 网络同步解决方案

#### 同步解决方案不仅用来逼真模拟其他玩家，还用来解决和优化网络传输数据的压力和部分渲染压力。

#### 状态同步

##### 服务器发送对应目标的对应状态，客户端根据目标状态播放动画、特效等

##### 给予相同数据，展现的状态效果都应该是相同的。

##### 当玩家进行操作时，不一定需要在收到同步信息后才展示状态。可以先展示状态，等服务器同步信息下来后再进行矫正。

#### 实时广播同步

##### 类似与fps游戏的旋转和移动变化次数较多的数值时，通过广播的方式进行同步。而不再通过服务器校验然年发送数值。

##### 可以在服务器增加验证机制，对广播的数值进行限制。

##### 如移动、旋转等数据，客户端在接收到时，需要进行插值的方式来修改移动、旋转等参数。让模拟更流畅。

##### 状态同步一般和实时广播同步一起使用。

#### 帧同步

##### 概述

###### 在同步性和安全性要求很高的游戏，每帧都是关键的。实时广播同步的弱校验已经无法满足，无法保证数据正确性。设备差异导致，同一段逻辑在不同设备性能下展示效果的程度也会有偏差。

###### 帧同步不再使用Update来作为逻辑帧，而是由网络收到的帧数据包来驱动执行逻辑更新。

###### 服务器端需要每个客户端每秒发送15-30个帧数据包，即每隔0.033~0.066秒一个，即使没有任何信息，也会发送空的帧数据，因为客户端需要根据帧数据来“演算”游戏逻辑。

###### 帧数据的集合被认为是一个时间线，用帧代替秒计算，如某个动作持续多少帧，使用整数而不是浮点数来计量时间线，更加准确。

###### 不同游戏设备在拥有不同帧率情况下，执行相同数量的逻辑帧的同时也执行了相同次数的逻辑指令。

###### 帧数据主要存储指令和指令相关的参数，当玩家对游戏操作时，向服务端发送指令。服务端在随后广播的帧数据中添加上传的指令，
客户端则不断收到服务端广播的帧数据，每帧都执行一次更新逻辑。

###### 在客户端执行帧数据的逻辑步骤中，会有渲染和逻辑的差异。渲染时通常在10~60帧范围内变化，而帧数据的频率则是固定的每秒15帧，导致产生差异。

###### 可以使用最近的3~5个帧来预测速度和加速度。如网络严重堵塞是，预测和模拟不再准确，应等帧数据到来再进行校准。

###### 最大特点：服务器控制所有玩家设备上的播放帧的速率和帧数长度，拥有相同的帧数据，执行相同的指令数量以及相同指令顺序，因此表现相同。

##### 同步快进

###### 网络延迟时，一次收到很多帧数据，为了同步帧数据的逻辑，避免一次性执行所有帧数据造成卡顿。可以采用每次执行N帧(N大于10)的方式使画面快速推进，同步完所有帧数据后，再恢复到正常执行速度。

###### 当掉线重连时，相当于落后了整个数据帧，可以使用内存快照的形式在服务器或本地做内存备份，客户端获取最后一帧数据计算后的内存数据，以此为依据渲染画面。

###### 发送指令过于频繁，也会造成网络数据的灾难。
客户端以渲染帧的速度大量向服务端发送指令数据，会造成帧数据混乱，每个玩家的指令一帧数据中只能有一个，才能不造成逻辑混乱。

####### 把需要发送的指令存储起来，等收到服务端的网络帧数据时再发送。如果指令过多，则不断替换未发送的指令。	

####### 确保一帧内不能有多个操作，确保逻辑简单化。

##### 精度问题

###### 不同设备浮点数精度损失，结果不同，导致细微差别经过长时间计算，会不断扩大。

###### 使用定点数

###### 最性价比的方式则是使用整数*1000或10000

##### 同步锁机制

###### 如星际争霸1，一个玩家卡顿，其他玩家都必须等待所有人网络正常。

###### 每个客户端每隔一段时间发送一个锁帧数据，类似心跳包告诉其他玩家还在线。

###### 超过指定时间没收到某个玩家的锁帧数据，则停止播放网络帧数据。

## UI

### UGUI原理及组件使用

#### UGUI运行原理

##### 所有可视化元素通过3D模型网格形式构建

##### 一个网格绑定一个材质球（也就是图集）只需要改变模型顶点UV和颜色

##### UGUI把相同层级、拥有相同材质进行静态合批成一个大网格。如改变任何元素参数都会销毁这个网格并重新构建一个。

##### 减少重构网格的次数，达到更少的性能开销

#### 组件

##### Canvas

###### 同一个Canvas内，相同层级(覆盖层级)、相同材质球会进行合批

###### Screen Camera模式相对通用，排序时z轴不为0的元素，会单独渲染。

##### CanvasScaler

###### Scale With Screen Size模式以屏幕为基准的自动适配，通常使用。

##### Graphic Raycaster

###### 仅检查Canvas下，元素存在碰撞体时会触发射线检测。

##### EventTrigger

###### 与此绑定的UI物体都可以接受输入事件，和Graphic Raycaster配合响应。

##### Image、RawImage

###### Image一般展示合并图集中的图片，每个图片都有一个Tag标记

###### 不使用图集时使用RawImage，通常图片尺寸太大合并图集浪费内存

##### Mask、RectMask2D

###### Mask使用顶点重构的方式剔除矩形区域外的部分。会生成独立材质球打断合批，两个Mask组件反而可以合批

###### RectMask2D采用着色器的剔除方式，还是原本材质球。

#### 事件系统源码剖析

##### 事件数据模块

###### PointerEventData(点位事件数据类)

###### AxisEventData(滚轮事件数据类)

###### BaseEventData(事件基础数据类)

###### 事件数据模块主要作用是，为事件逻辑做好数据工作。

##### 输入事件捕获模块

###### BasInputModule(抽象类、基类)

###### PointerInputModule

###### StandaloneInputModule

###### TouchInputModule

