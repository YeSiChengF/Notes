# 框架搭建随笔

## 版本号

使⽤版本号命名的⽂件格式为: Framework_vX.Y.Z
- X 是主版本号，⽤于不向前兼容的更新。
- Y 是中间版本，⽤于可向前兼容的功能性更新。
- Z 是⼩版本号，⽤于功能完善和 bug 修复的更新

⼀般都是从 v0.1.1 这个版本开始发布的，但是这个版本呢叫做 mvp 版本，也就是最⼩可验证版本。后续发布版本都需要向前兼容

## Obsolete 标签

使用Obsolete标签标记方法已弃用，使用其他方法。

添加弃用标签后会报警报提醒

```c#
[Obsolete("方法已过时，请使用xx方法")]
public static void OpenInFolder(string folderPath)
{
	Application.OpenURL("file://" + folderPath);
}
```

## Partial关键字

当类后续可能增长的时候使用，各个部分类需要用相同的访问权限。而且每个部分类都需要加`partial`关键字。

## 方法结构重复 解决方案

当一个方法的的参数类型不同时，如果有共同父类可以将类型设置为父类，子类可以进行使用

```c#
public static int GetRandomValueFrom(int[] values)
{
    return values[Random.Range(0, values.Length)];
}
public static float GetRandomValueFrom(float[] values)
{
    return values[Random.Range(0, values.Length)];
}
public static string GetRandomValueFrom(string[] values)
{
    return values[Random.Range(0, values.Length)];
}
```

可以将类型设置为object

```c#
public static object GetRandomValueFrom(object[] values)
{
    return values[Random.Range(0, values.Length)];
}
```

### 泛型实现结构复用

使用泛型实现方法复用

```c#
public static T GetRandomValueFrom<T>(params T[] values)
{
    return values[Random.Range(0, values.Length)];
}
```

### params关键字

修饰形参**必须为一维数组**，并且方法声明只能有一个`params`，如果不是一维数组编译器将报错。

使用 `params` 参数调用方法时，可以传入：

- 数组元素类型的参数的逗号分隔列表。

- 指定类型的参数的数组。

- 无参数。 如果未发送任何参数，则 `params` 列表的长度为零。

``` c#
//数组元素类型的参数的逗号分隔列表
public void Get()
{
	GetRandomValueFrom<int>(1, 2, 3);
}
//无参数
public void Get()
{
	GetRandomValueFrom<int>();
}
```

## 消息机制

### Unity内置消息机制

方法调用使用字符串，可能用到反射，尽量不用。

```c#
this.SendMessageUpward("MethedName");
```

### 通过委托通知

A注册特定方法，B声明委托。当B想调用A的方法时，通过委托通知。

### 消息机制提供的功能

- 注册事件
- 注销事件
- 发送事件

```c#
MsgDispatcher.Register("消息名",(obj)=>{ /* 处理消息 */ });
MsgDispatcher.Send("消息名","消息内容");
MsgDispatcher.UnRegister("消息名");
```

## new Class的优化

当一个class作为存储数据时，为了减少new的次数可以做一个对象池进行存储

```c#
private class MsgRecord
{
    //私有构造函数后，class无法被new
    private MsgRecord() { }
    //对象池
    static Stack<MsgRecord> mMsgRecordPool = new Stack<MsgRecord>();
    //创建对象
    public static MsgRecord Allocate(string msgName, Action<object> onMsgReceived)
    {
        MsgRecord msgRecord;
        if (mMsgRecordPool.Count > 0)
        {
            msgRecord = mMsgRecordPool.Pop();

        }
        else
        {
            msgRecord = new MsgRecord { };
        }
        msgRecord.Name = msgName;
        msgRecord.OnMsgReceived = onMsgReceived;
        return msgRecord;
    }
    //移除对象
    public void Recycle()
    {
        Name = null;
        OnMsgReceived = null;
        mMsgRecordPool.Push(this);
    }
    public string Name;
    public Action<object> OnMsgReceived;
}
```

## 框架的定义

`框架`：提供⼀个架构（⽂件结构、约定等等），你必须遵守它，只要你遵守，那剩下的就 全部处理通⽤需求了。 

## 库的定义

库，插到既有 架构上，补充特定功能。

## Unity常用架构

### 1.EmptyGo

 在 Hierarchy 上创建⼀个空的 GameObject,然后挂上所有与 GameObject ⽆关的逻辑控制的脚 本。使⽤GameObject.Find() 访问对象数据。 

缺点:逻辑代码散落在各处,不适合⼤型项⽬。 

###  2.Simple GameManager

所有与 GameObject ⽆关的逻辑都放在⼀个单例中。 

缺点:单⼀⽂件过于庞⼤ 

###  3.Manager Of Managers

将不同的功能单独管理。

如下:

- MainManager: 作为⼊⼝管理器。

- EventManager: 消息管理。 

- GUIManager: 图形视图管理。 

- AudioManager: ⾳效管理。

- PoolManager: GameObject管理（减少动态开辟内存消耗,减少GC)。 

- LevelManager: 关卡管理。 

- GameManager: 游戏管理。

- SaveManager: 配置&存储管理。

- MenuManager 菜单管理。 


### 4.将 View 和 Model 之间增加⼀个媒介层

 MVCS:StrangeIOC 插件。 MVVM:uFrame 插件

### 5.ECS (Entity Component Based System) 

 Unity 是基于 ECS,⽐较适合 GamePlay 模块使⽤ 

## Manager Of Managers架构模式