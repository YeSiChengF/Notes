# 框架搭建随笔

## 版本号

使⽤版本号命名的⽂件格式为: Framework_vX.Y.Z
- X 是主版本号，⽤于不向前兼容的更新。
- Y 是中间版本，⽤于可向前兼容的功能性更新。
- Z 是⼩版本号，⽤于功能完善和 bug 修复的更新

⼀般都是从 v0.1.1 这个版本开始发布的，但是这个版本呢叫做 mvp 版本，也就是最⼩可验证版本。后续发布版本都需要向前兼容

## Obsolete 标签

使用Obsolete标签标记方法已弃用，使用其他方法。

添加弃用标签后会报警报提醒

```c#
[Obsolete("方法已过时，请使用xx方法")]
public static void OpenInFolder(string folderPath)
{
	Application.OpenURL("file://" + folderPath);
}
```

## Partial关键字

当类后续可能增长的时候使用，各个部分类需要用相同的访问权限。而且每个部分类都需要加`partial`关键字。

## 方法结构重复 解决方案

当一个方法的的参数类型不同时，如果有共同父类可以将类型设置为父类，子类可以进行使用

```c#
public static int GetRandomValueFrom(int[] values)
{
    return values[Random.Range(0, values.Length)];
}
public static float GetRandomValueFrom(float[] values)
{
    return values[Random.Range(0, values.Length)];
}
public static string GetRandomValueFrom(string[] values)
{
    return values[Random.Range(0, values.Length)];
}
```

可以将类型设置为object

```c#
public static object GetRandomValueFrom(object[] values)
{
    return values[Random.Range(0, values.Length)];
}
```

### 泛型实现结构复用

使用泛型实现方法复用

```c#
public static T GetRandomValueFrom<T>(params T[] values)
{
    return values[Random.Range(0, values.Length)];
}
```

### params关键字

修饰形参**必须为一维数组**，并且方法声明只能有一个`params`，如果不是一维数组编译器将报错。

使用 `params` 参数调用方法时，可以传入：

- 数组元素类型的参数的逗号分隔列表。

- 指定类型的参数的数组。

- 无参数。 如果未发送任何参数，则 `params` 列表的长度为零。

``` c#
//数组元素类型的参数的逗号分隔列表
public void Get()
{
	GetRandomValueFrom<int>(1, 2, 3);
}
//无参数
public void Get()
{
	GetRandomValueFrom<int>();
}
```

## 消息机制

### Unity内置消息机制

方法调用使用字符串，可能用到反射，尽量不用。

```c#
this.SendMessageUpward("MethedName");
```

### 通过委托通知

A注册特定方法，B声明委托。当B想调用A的方法时，通过委托通知。

### 消息机制提供的功能

- 注册事件
- 注销事件
- 发送事件

```c#
MsgDispatcher.Register("消息名",(obj)=>{ /* 处理消息 */ });
MsgDispatcher.Send("消息名","消息内容");
MsgDispatcher.UnRegister("消息名");
```

## new Class的优化

当一个class作为存储数据时，为了减少new的次数可以做一个对象池进行存储

```c#
private class MsgRecord
{
    //私有构造函数后，class无法被new
    private MsgRecord() { }
    //对象池
    static Stack<MsgRecord> mMsgRecordPool = new Stack<MsgRecord>();
    //创建对象
    public static MsgRecord Allocate(string msgName, Action<object> onMsgReceived)
    {
        MsgRecord msgRecord;
        if (mMsgRecordPool.Count > 0)
        {
            msgRecord = mMsgRecordPool.Pop();

        }
        else
        {
            msgRecord = new MsgRecord { };
        }
        msgRecord.Name = msgName;
        msgRecord.OnMsgReceived = onMsgReceived;
        return msgRecord;
    }
    //移除对象
    public void Recycle()
    {
        Name = null;
        OnMsgReceived = null;
        mMsgRecordPool.Push(this);
    }
    public string Name;
    public Action<object> OnMsgReceived;
}
```

## 框架的定义

`框架`：提供⼀个架构（⽂件结构、约定等等），你必须遵守它，只要你遵守，那剩下的就 全部处理通⽤需求了。 

**好架构=好规则**

## 库的定义

库，插到既有 架构上，补充特定功能。

## Unity常用架构

### 1.EmptyGo

 在 Hierarchy 上创建⼀个空的 GameObject,然后挂上所有与 GameObject ⽆关的逻辑控制的脚 本。使⽤GameObject.Find() 访问对象数据。 

缺点:逻辑代码散落在各处,不适合⼤型项⽬。 

###  2.Simple GameManager

所有与 GameObject ⽆关的逻辑都放在⼀个单例中。 

缺点:单⼀⽂件过于庞⼤ 

###  3.Manager Of Managers

将不同的功能单独管理。

如下:

- MainManager: 作为⼊⼝管理器。
- EventManager: 消息管理。 
- GUIManager: 图形视图管理。 
- AudioManager: ⾳效管理。
- PoolManager: GameObject管理（减少动态开辟内存消耗,减少GC)。  存储各类型的spawnPool，spawnpool存储各prefabPool。删除和添加时如果不需要立即操作，可以分步进行添加删除。(最基本拥有) 
- LevelManager: 关卡管理。 (最基本拥有)
- GameManager: 游戏管理。
- SaveManager: 配置&存储管理。(最基本拥有)
- `Easy save2`插件使用二进制操作 ，对数据加密
- MenuManager 菜单管理。 


### 4.将 View 和 Model 之间增加⼀个媒介层

UI和逻辑分离

 MVCS:

​	StrangeIOC 插件。

​	`IBinder.Bind<Key>().To<Value>();`

​	`IBinder.Bind<Key>().To<Value>().ToName(name);`当key和value都相同时，根据name区分

​	通过event和listener来触发按键的操作

​	机制依赖于C#的Reflection(反射)，效率慢，模式、思想和理念可借鉴

MVVM:

​	uFrame 插件

### 5.ECS (Entity Component Based System) 

 Unity 是基于 ECS,⽐较适合 GamePlay 模块使⽤ 

## Manager Of Managers架构模式

### LevelManager

Unity里的`LoadScene方法`只能传递scene名字或index。改名或者变换顺序时变得非常麻烦。通过配置表配置，读取level时按顺序读取配置表即可。

### PoolManager

两个经典操作，Spawn、Despawn
#### Spawn
在创建新资源时，对象池有则直接调用，没有则需要初始化。
#### DeSpawn
当池子容量达到指定上限时，将第一个第二个按照队列顺序进行销毁，先进先出。

#### 对象池优化

一个PoolManager下有若干个SpawnPool来管理一类的物体。比如NPC一个Pool，物品一个Pool。一个SpawnPool有若干个PrefabPool，一个PrefabPool只能存储一个Prefab，可以进行单个Prefab的加载和卸载。

对于每一个PrefabPool可以管理两个List，一个是ActivetedList，一个是DeactivateList，并管理所有Prefab的加载和卸载过程。

在删除时对数量要严格控制，一帧内不能同时删除太多物体，否则会触发GC。需要PoolManager管理时能够缓释，一帧只删除少量对象。

### SaveManager

`Easy Save2`二进制进行Load和Save，与Unity很好的结合，Unity类型基本都能Serialized。比Json的一些方案快。

### MainManager

入口管理器，如资源加载流程、第三方SDK启动流程、热更新检测，都是在入口处完成的。

在开发阶段不同流程会有不同的log或调试需要进行阶段划分进行屏蔽。

职责：

- 管理多个入口
- 负责游戏的启动流程。

####  阶段划分

1. 开发阶段:不断编码->验证结果->编码->验证结果->....
2. 出包/真机阶段：跑完整流程，QA测试
3. 发布阶段：上线

对应的枚举

```c#
public enum EnvironmentMode{
    Developing,
    QA,
    Release
}
```

根据枚举执行抽象方法
```c#
private void Start()
{
    switch (mode)
    {
        case EnvironmentMode.Developing:
            LaunchInDevelopingMode();
            break;
        case EnvironmentMode.Test:
            LaunchInTestMode();
            break;
        case EnvironmentMode.Production:
            LaunchInProductionMode();
            break;
    }
}
protected abstract void LaunchInDevelopingMode();
protected abstract void LaunchInTestMode();
protected abstract void LaunchInProductionMode();
```

