# 资源

## AssetBundle

### 一个AssetBundle有什么？

- 一个序列化文件，标识符、是否压缩和清单(manifest)数据。
  - manifest数据是由对象的名称为key的查找表(lookup table)，每个条目都提供了一个字节的索引来标识对象在AssetBundle数据段的位置
- 资源文件，二进制数据块，支持异步加载
  - 所有资源都被序列化，如果选择压缩则将序列化数据压缩。

### AssetBundle的压缩方式

#### LZMA

基于文件流

包体小，解压时间长

因为使用流的方式，所以使用时必须加载整包，解压后会被重新压缩成LZ4

#### LZ4

基于块(Chunk)的算法，读取文件时只需要解压文件所在的块数据

加载速度和不加载速度差不多，优势在于在内存中的占用变小了

会比LZMA的包体大25%，可以使用其他压缩手段进行二次压缩，包体也可以被压得很小。

### AssetBundle的卸载

#### AssetBundle.Unload(true)

强制卸载掉所有AssetBundle中加载的Asset，包括AssetBundle的映射结构，和从AssetBundle创建出来的所有资源。释放AssetBundle实例。

**会导致正在使用的资源丢失**，需要一套自己的机制来关注是否有正在使用的资源。

#### AssetBundle.Unload(false)

AssetBundle内的序列化数据会被释放，正在使用的资源还保持完好。等于断开了AssetBundle和实例的联系。再次使用这个AB包时，则会重新实例化一个新的，旧的就引用不到了。就造成了重复资源的冗余。

#### Resources.UnloadUnusedAssets

卸载掉没有使用的Assets，作用范围是整个系统。

作用方式类似于GC，会遍历所有资源进行引用查询，会阻塞线程。

#### 小结

`AssetBundle.Unload(false)`更适用于一次性使用的资源，卸载后，在特定时机触发`Resources.UnloadUnusedAssets`就能卸载干净了。

`AssetBundle.Unload(true)`使用时最好添加引用计数作为保护。

