# 网络游戏架构设计

## 第一节 代码结构

### 项目代码结构需要满足的需求

#### 热更新

需要把Unity的MonoBehaviour等等这些和Unity交互较深的脚本进行分离

至少有一个热更新的程序集

#### 数据跟方法分离，热重载

##### 热重载

​	热重载只是数据跟方法分离后得到的好处

​	热重载便于改bug，节省重现环节。

##### 数据跟方法分离

​	在C语言中叫做`data + function`的设计。数据就是定义数据结构，方法则是面向过程的方法。

​	相比于面向对象而已没有类与类之间的关联，只有方法和方法的关联，便于重构。

#### 逻辑跟表现分离

数据是同步的，而表现可能是异步的情况。在表现过程中可能会有一些资源加载的操作，在这个过程中逻辑发生了变化，表现也需要发生变化。

预表现。表现层可能提前做出一些表现比如一些战斗前摇，但是对逻辑层没有什么影响。等逻辑层同步了命中逻辑后，再播放命中的表现。

在MMO的切换场景中，服务器通知场景切换后，客户端逻辑层加载数据，表现层则在数据加载完成后开始异步加载场景。服务器再通知单位模型的数据后，客户端逻辑层整理数据后，表现成开始异步加载单位模型。

帧同步。帧同步两端的逻辑层的逻辑是一样的。而状态同步逻辑在服务端，两端的逻辑层实际上也是一样的。区别只在于一个是客户端计算一个是服务端计算。 帧同步如果把逻辑层看做是一个服务端，看起来就像是逻辑层在给表现层发消息。逻辑是离散的，表现是要做插值的。

#### ECS数据驱动

数据变化是通过事件通知的。逻辑和表现监听事件产生变化。

### ET版本变更

#### 1.0

客户端

- Hoxfix 热更层
- Main 主工程

服务端

- Hoxfix 纯逻辑
- Main 纯数据

#### 中间版本

客户端 

asmdef功能，多个程序集提升编译速度

- Hoxfix	热更层
- Loader 游戏入口，可放Unity脚本
- Core 框架核心
- ThirdParty 第三方库

服务端

- Hoxfix
- Model
- Loader
- Core
- ThirdParty

#### 热重载需求

客户端

- Hoxfix 热更层的逻辑层  
  - 纯逻辑改变时不用关闭，直接重载这个程序集
- Model 热更层的数据层
- Loader 游戏入口，可放Unity脚本
- Core 框架核心
- ThirdParty 第三方库

#### 另一种划分

- HoxfixView 表现层
- Hoxfix 逻辑层 抛事件通知表现层
- Loader
- ThridParty
- Core

#### 结合前面两个版本

##### 客户端

- HoxfixView 表现层的方法
- ModelView 表现层数据结构
- Hofix 逻辑层方法
- Model 逻辑层数据
- Loader
- Core
- ThridParty

前四个程序集编译在一起做热更新。HofixView和Hofix编译在一起做热重载。

并且逻辑和表现分离

##### Robot

- Hofix 逻辑层方法
- Model 逻辑层数据
- Loader
- Core
- ThridParty

去掉客户端的表现层，就是机器人的程序集了。

Hofix和Model共用客户端的程序集。

## 第二节 All In One

### 各类服务器进程合并

很多多进程的设计，都把一个服务整理成一个exe。多个服务就有多个exe，代码可能是高度相似的。只是启动时环境变量不同。合并成一个exe并设置环境变量。

### 后端和机器人合并

### 前端跟后端合并

