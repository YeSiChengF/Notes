# 帧同步设计

## 第1节 简介

### 状态同步

- 逻辑计算在服务器
- 服务器同步变化给客户端
- 客户端只做表现

###  帧同步

- 服务器广播客户端指令
- 逻辑计算在客户端逻辑层
- 客户端逻辑层发送变化给表现层
- 相当于把状态同步的服务器挪到了客户端逻辑层

#### 适合的场景

操作少，逻辑变化多

同场景玩家数少，需要同时同步的数量少

同视野单位特别多的场景

只适合开房间类型

不太需要单位信息保密的场景，安全性等级较低的场景

以上条件缺一不可

#### 帧同步优势

- 流量少
  - 具体流量多少看玩家数量
- 录像文件小
  - 只需要记录操作
  - 状态同步则是保存协议消息
- 服务器不做验证的话，服务器消耗小

#### 帧同步误区

- 帧同步手感更好
- 帧同步开发简单，难度低
- 帧同步对网络速度要求低
  - 如果需要体验流畅反而网络要求更高
- 帧同步各个客户端表现一模一样
  - 只能保证逻辑层一致
- 帧同步可以减少服务器

#### 帧同步的几种方案

- 服务器消息驱动帧同步：服务端固定帧率收集消息，定时广播，客户端指令没有帧的概念，帧是由服务端消息驱动的，适合玩家数量稍多的场景，预测只能做表现层的预测，开发难度相对简单
- 预测回滚帧同步：服务的固定帧率收集消息，客户端也有自己的帧，适合2-3人的场景，逻辑层有做预测，预测失败则回滚，开发难度大

## 第2节 网络0GC处理

### 0GC的消除策略

0GC就是不分配，共用对象池。但是多线程情况下共用对象池存在风险。

服务端不消除GC

客户端手动消除消息GC，消除量级比较大的消息

### 0GC的方式

- MessagePool
  - 线程安全的消息对象池
- MemoryPack提供了ref的反序列化方式
  - 不是new对象的形式
- 消息中的成员回收
- 消息中容器回收，MemoryPack会对容器调用Clear，容器中最好是struct
  - MemoryPack构建struct的时候用的非反射方式，没有拆装箱避免了gc
- MemorySteam GC消除
- Udp Send Recv GC消除

### 消息的创建回收

- MessageObject.IsFromPool
  - 消息都继承于MessageObject
- 发送消息时创建，消息传到网络层序列化完成后回收
  1. 发送的时候需要自己调用Create(true);
  2. 回收是框架自动调用Dispose();
- 接受消息时创建，消息传到主线程使用完成后回收
  1. 接收的时候框架自动调用FetchMessage
  2. 回收需要自己调用Dispose();

### MemoryBuffer创建回收

MemoryBuffer是MemoryStream子类，主要为了配合MemoryPack用的

IBufferWriter接口

框架自动回收，使用者不需要关心

### MemoryPack Source Generator

不像protobuf通过反射生成代码，完全支持unity

AssemblyBuilder失效

使用IDE编译Dll，所有代码放到Unity.Codes工程里面，开启ENABLE_CODES启用dll模式，跟ET7中相反

Unity.Codes分成Model跟Hotfix，报错，没找到问题，所以客户端热重载暂时不能用

## 第3节 框架层调整

1. EntityRef
   - 原本对Entity的引用只能通过InstanceId，现在增加EntityRef持有Entity
   - 当Entity被释放或者回收掉时，再去取EntityRef则为null
2. Entity不再统一注册到Root中
   - 在原本的设计中Root管理Entity，通过InstanceId为key来取出Entity。
   - 只有Actor对象的Entity挂载了MailboxComponent的才会注册到ActorMessageDispatcherComponent中
3. TypeSystem EntitySystemSingleton，可扩展的Entity System机制
   - 把之前EventSystem内一些生命周期的事件，抽出到EntitySystemSingleton中。
   - LSEntitySystemSingleton
4. Domain IScene, 更完善，Scene的代码都简化了
   - 只要Entity有IScene接口都可以是Domain
   - Scene中简化了Parent和Domain的字段
5. Entity中Components改成SortedDictionary，保证有序
   - 原本的Entity中的Components只是字段，在不同机器上的hash值不一样顺序也不一样。帧同步则会有问题，在Entity执行Disponse时，不同机器移除顺序不同则会造成问题。
6. Mongo序列化BeginInit, SerializeSystem
   - Entity序列化时，调用BeginInit遍历判断Componets是否有ISerializeToEntity接口，有则加入ComponentDB
   - 增加SerializeSystem，用于判断有些同类型Entity哪些需要存储哪些不需要存储。
7. 配置文件改成了Bson，直接支持Dictionary

## 第4节 帧同步架构

![image-20230817212941518](帧同步设计.assets/image-20230817212941518.png)

- 客户端的Room相比服务端的Room多了个表现层
- 客户端挂载的是LSClientUpdate，服务端挂载的是LSServerUpdate，客户端相对服务端而言多了预测回滚的功能。

## 第5节 LSEntity

### 为什么要LSEntity

1. 限制Entity的Id生成
   - Entity的id都是通过IdGenerater生成，那么不同设备上生成出来的id会不一致。会导致逻辑不一致。
   - LSEntity AddChild和AddComponent时生成的id是统一的。
   - LSEntity 的Id序列化和反序列操作后不变。
2. LSWorld不能使用Update LateUpdate Load等等
   - 需要专用的Update类似于FixedUpdat e，每固定时间触发。
   - 服务器的Load和客户端的Load，代码不一致可能导致结果也不一致。
3. 序列和反序列化导致InstanceId跟System绑定关系失效，不能写一个老式的FixedUpdate
   - 回滚逻辑在把操作进行序列化和反序列后，instanceId产生变化会自增1，导致失效。
4. 用Id跟System绑定，专用的 LSUpdateSystem
   - FixedUpdateSystem的实现
5. 可以针对LSEntity，加上float分析器限制

### LSWorld：LSEntity

LSWorld只能挂在LSEntity

1. 定点数部分，纯逻辑层
   - 没必要所有代码都使用定点数，只有在于帧同步玩法内才需要。比如Room内LSWorld部分才使用定点数。
2. 序列化反序列化, 回滚的部分
   - 只有逻辑层、纯定点数部分才需要回滚。
3. Id生成器
4. 随机数
   - 服务器生成的随机数种子，使客户端通过Id生成器生成的Id能保持一致。
5. LSUpdater，注意，这个不是fixedUpdate，记录有哪些Entity有LSUpdate

### System

- LSEntitySystemSington
- LSUpdateSystem
- LSRollbackSystem
  - 和表现层做和解用的

### LSUpdater.Update驱动

Room上挂有一个Updater组件，在固定帧调用LSWorld的Updater

客户端的Update间隔和服务端不一致，客户端可能需要动态调整，时间的膨胀、搜索。在服务端的Room上挂服务端的Update组件，在客户端的Room上挂客户端的Update组件。

### LSRollbacke

在表现层使用，用于状态回滚