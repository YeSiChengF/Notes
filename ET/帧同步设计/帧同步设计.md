# 帧同步设计

## 第1节 简介

### 状态同步

- 逻辑计算在服务器
- 服务器同步变化给客户端
- 客户端只做表现

###  帧同步

- 服务器广播客户端指令
- 逻辑计算在客户端逻辑层
- 客户端逻辑层发送变化给表现层
- 相当于把状态同步的服务器挪到了客户端逻辑层

#### 适合的场景

操作少，逻辑变化多

同场景玩家数少，需要同时同步的数量少

同视野单位特别多的场景

只适合开房间类型

不太需要单位信息保密的场景，安全性等级较低的场景

以上条件缺一不可

#### 帧同步优势

- 流量少
  - 具体流量多少看玩家数量
- 录像文件小
  - 只需要记录操作
  - 状态同步则是保存协议消息
- 服务器不做验证的话，服务器消耗小

#### 帧同步误区

- 帧同步手感更好
- 帧同步开发简单，难度低
- 帧同步对网络速度要求低
  - 如果需要体验流畅反而网络要求更高
- 帧同步各个客户端表现一模一样
  - 只能保证逻辑层一致
- 帧同步可以减少服务器

#### 帧同步的几种方案

- 服务器消息驱动帧同步：服务端固定帧率收集消息，定时广播，客户端指令没有帧的概念，帧是由服务端消息驱动的，适合玩家数量稍多的场景，预测只能做表现层的预测，开发难度相对简单
- 预测回滚帧同步：服务的固定帧率收集消息，客户端也有自己的帧，适合2-3人的场景，逻辑层有做预测，预测失败则回滚，开发难度大

## 第2节 网络0GC处理

### 0GC的消除策略

0GC就是不分配，共用对象池。但是多线程情况下共用对象池存在风险。

服务端不消除GC

客户端手动消除消息GC，消除量级比较大的消息

### 0GC的方式

- MessagePool
  - 线程安全的消息对象池
- MemoryPack提供了ref的反序列化方式
  - 不是new对象的形式
- 消息中的成员回收
- 消息中容器回收，MemoryPack会对容器调用Clear，容器中最好是struct
  - MemoryPack构建struct的时候用的非反射方式，没有拆装箱避免了gc
- MemorySteam GC消除
- Udp Send Recv GC消除

### 消息的创建回收

- MessageObject.IsFromPool
  - 消息都继承于MessageObject
- 发送消息时创建，消息传到网络层序列化完成后回收
  1. 发送的时候需要自己调用Create(true);
  2. 回收是框架自动调用Dispose();
- 接受消息时创建，消息传到主线程使用完成后回收
  1. 接收的时候框架自动调用FetchMessage
  2. 回收需要自己调用Dispose();

### MemoryBuffer创建回收

MemoryBuffer是MemoryStream子类，主要为了配合MemoryPack用的

IBufferWriter接口

框架自动回收，使用者不需要关心

### MemoryPack Source Generator

不像protobuf通过反射生成代码，完全支持unity

AssemblyBuilder失效

使用IDE编译Dll，所有代码放到Unity.Codes工程里面，开启ENABLE_CODES启用dll模式，跟ET7中相反

Unity.Codes分成Model跟Hotfix，报错，没找到问题，所以客户端热重载暂时不能用

## 第3节 框架层调整

1. EntityRef
   - 原本对Entity的引用只能通过InstanceId，现在增加EntityRef持有Entity
   - 当Entity被释放或者回收掉时，再去取EntityRef则为null
2. Entity不再统一注册到Root中
   - 在原本的设计中Root管理Entity，通过InstanceId为key来取出Entity。
   - 只有Actor对象的Entity挂载了MailboxComponent的才会注册到ActorMessageDispatcherComponent中
3. TypeSystem EntitySystemSingleton，可扩展的Entity System机制
   - 把之前EventSystem内一些生命周期的事件，抽出到EntitySystemSingleton中。
   - LSEntitySystemSingleton
4. Domain IScene, 更完善，Scene的代码都简化了
   - 只要Entity有IScene接口都可以是Domain
   - Scene中简化了Parent和Domain的字段
5. Entity中Components改成SortedDictionary，保证有序
   - 原本的Entity中的Components只是字段，在不同机器上的hash值不一样顺序也不一样。帧同步则会有问题，在Entity执行Disponse时，不同机器移除顺序不同则会造成问题。
6. Mongo序列化BeginInit, SerializeSystem
   - Entity序列化时，调用BeginInit遍历判断Componets是否有ISerializeToEntity接口，有则加入ComponentDB
   - 增加SerializeSystem，用于判断有些同类型Entity哪些需要存储哪些不需要存储。
7. 配置文件改成了Bson，直接支持Dictionary

## 第4节 帧同步架构

![image-20230817212941518](帧同步设计.assets/image-20230817212941518.png)

- 客户端的Room相比服务端的Room多了个表现层
- 客户端挂载的是LSClientUpdate，服务端挂载的是LSServerUpdate，客户端相对服务端而言多了预测回滚的功能。

## 第5节 LSEntity

### 为什么要LSEntity

1. 限制Entity的Id生成
   - Entity的id都是通过IdGenerater生成，那么不同设备上生成出来的id会不一致。会导致逻辑不一致。
   - LSEntity AddChild和AddComponent时生成的id是统一的。
   - LSEntity 的Id序列化和反序列操作后不变。
2. LSWorld不能使用Update LateUpdate Load等等
   - 需要专用的Update类似于FixedUpdate，每固定时间触发。
   - 服务器的Load和客户端的Load，代码不一致可能导致结果也不一致。
3. 序列和反序列化导致InstanceId跟System绑定关系失效，不能写一个老式的FixedUpdate
   - 回滚逻辑在把操作进行序列化和反序列后，instanceId产生变化会自增1，导致失效。
4. 用Id跟System绑定，专用的 LSUpdateSystem
   - FixedUpdateSystem的实现
5. 可以针对LSEntity，加上float分析器限制

### LSWorld：LSEntity

LSWorld只能挂在LSEntity

1. 定点数部分，纯逻辑层
   - 没必要所有代码都使用定点数，只有在于帧同步玩法内才需要。比如Room内LSWorld部分才使用定点数。
2. 序列化反序列化, 回滚的部分
   - 只有逻辑层、纯定点数部分才需要回滚。
3. Id生成器
4. 随机数
   - 服务器生成的随机数种子，使客户端通过Id生成器生成的Id能保持一致。
5. LSUpdater，注意，这个不是fixedUpdate，记录有哪些Entity有LSUpdate

### System

- LSEntitySystemSington
- LSUpdateSystem
- LSRollbackSystem
  - 和表现层做和解用的

### LSUpdater.Update驱动

Room上挂有一个Updater组件，在固定帧调用LSWorld的Updater

客户端的Update间隔和服务端不一致，客户端可能需要动态调整，时间的膨胀、搜索。在服务端的Room上挂服务端的Update组件，在客户端的Room上挂客户端的Update组件。

### LSRollbacke

在表现层使用，用于状态回滚。表现层向逻辑层进行一一核对。

## 第6节 预测回滚

### Room

#### FrameBuffer输入缓存

给记录的帧率限定数量，当超过限定值时则从记录的第一帧开始覆盖。

- 记录所有人的输入。每一帧的输入，每一帧都是一个字典。
- 每一帧的快照，记录帧并序列化。
- 每一帧都有一个hash值，用于做帧内容的对比。

#### FixedTimeCounter 固定时间计算，固定时间可改变

用来计算FixedUpdate的时间，到FixedTime的时间才会调用LSWorld的Update。

为什么不用固定时间调用？因为每帧时间不是固定的，客户端的时间会膨胀收缩。如果客户端的时间比服务端慢了，那么客户端的帧的间隔会减小。因为要保证客户端的预测帧一直跑在服务器的权威帧之前。

#### LSWorld

Room的child 可以有多个，持有Ref的引用性能会高些。

#### PredictionFrame 预测帧 AuthorityFrame 权威帧

预测帧就是客户端根据玩家操作预测出来的帧。服务器在做转发时，如果当前帧有玩家没输入则使用上一帧输入的数据做预测。

权威帧对客户端而言就是服务器下发的帧，确认帧。对服务端而言不做预测所以都是权威帧。

### 预测

作用：

1. 本地立即响应
2. 提前发送操作给服务端，服务端的权威帧跑到了后可以马上广播

策略：

1. 客户端预测自己的输入，直接获取。
2. 客户端预测别人的输入，取上一帧的输入。避免权威帧到了之后做过多的回滚操作，因为大概率操作和上一帧一样。 
3. 服务的预测，时间到了，客户端的输入没有发送过来，直接取客户端上一帧的输入，相当于丢弃客户端的输入。

### 权威消息处理

1. 权威消息比预测消息早

   如果预测消息晚于权威消息，那么直接使用权威帧就不用预测了。

2. 权威消息跟预测内容一样

   消息一样则不用处理

3. 权威消息跟预测消息不一致

   如果和预测消息不同，那么就需要进行回滚。客户端先把权威帧的数据拷贝到预测帧中，然后回滚到权威帧时的world，然后执行权威帧。权威帧后面从帧数则要重新进行预测。

   表现层，遍历Room下所有非LSEntity的Components，因为LSEntity是数据层使用的，然后做递归遍历执行所有的RollbackSystem。

## 第7节 客户端时间膨胀收缩-检测不同步

客户端的预测帧需要在服务端处理到权威帧下一帧之前到达服务端。

### 动态调整客户端fixedTime

每秒钟，服务端发送客户端的消息延迟时间给客户端 Room2C_AdiustUpdateTime

#### **消息延迟的时间怎么算？**

比如当服务器跑到第2帧了，但是服务器只记录了第0帧的输入数据，那差距就是2帧的时间。

当客户端收到服务端同步的消息延迟时，缩放update的间隔，在一秒内完成调整(把每一帧的时间平均分一下)。

#### 调整公式

`新的一帧时间 = （原来的一帧时间 + ( diffTime - 一帧时间 ) ）/ ( 1000 / 一阵时间 )`

ps: `diffTime - 一帧时间` ，因为预期是快一帧的时间所以减去一帧时间。

#### 调整限制

给调整的时间加个限制，如果一秒内调整不完那就放到下一秒调整。

最快一秒25帧，最慢一秒15帧

### 不同步检测

客户端权威帧改变的时候，计算lsworld序列化的hash值给服务端，服务端对比hash值