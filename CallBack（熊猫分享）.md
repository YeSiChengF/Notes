# CallBack（熊猫分享）

## **Callback**

提高cpu利用率不会造成阻塞。做一件事不会等待，等需要时再call back处

### 应用场景

- DMA控制器 

cpu做数据复制时会阻塞cpu，cpu 通知硬件进行复制完成后通知回来。不会阻塞整个cpu

- 网络多路复用

Socket读写过程中，等待数据发送或接收过程cpu的阻塞。等数据过来后再进行通知。

- 多线程

- 时间

比如等待5秒后执行一个函数指针不需要一直等待

### **函数指针**

C语言内通过函数指针的方式，在callback 后用指针执行函数，但是不方便同步上下文且类型不安全（可以传递任意指针）

### **函数对象**

C++通过函数对象的方式，类型安全、构造时传递函数指针、构造时传递上下文、绑定上下文

将上下文和回调函数封装成一个类（闭包），做到延迟调用。闭包比较繁琐，当需要上下文对象类型不满足已有扩展的闭包支持的类型时就要进行 闭包类型的扩展。

### **谷歌的NewCallBack**

上下文只能绑定前面的参数不能绑定后面的参数、返回的是指针（本质是new一个函数对象执行）如果没有调用会造成内存泄漏（解决方案：使用智能指针包裹）

## **Callback Hell**

回调地狱

处理回调的逻辑会被截成两段，一段是发起callback 一段是响应callback 

易出错、难修改。在callback 中难插入。

## async await Task

把int Func() (回调)转成await Func()

通过转换工具TaskCompletionSource <T>转换

## **ETTask**

- 简化的Task 生成代码简单

(.Net Reflector 可以.net stand 2.0反编译)

- 解决了Gc问题 

Task 使用TaskCompletionSource工具类转换成await Func 时会new 工具类

ETTask在确保安全的时候使用池消除gc，Set Result (true)时回收

TaskCompletionSource和Task合并

- 不提供多线程处理

## 并行

ET提供`WaitAll` `WaitAny`，类比线程同步barrier

当多个回调同时发起，等所有回调执行完再往下执行

场景：

1. 切换场景资源,不需要一个个加载，可以同时加载，等所有加载完再往下执行。
2. 机器人登录50个，不需要一个个登录。

### 协程锁

应用场景：

1. 两个逻辑同时加载同一个ab包
2. 服务器玩家异步加载处理到一半，这时收到下线消息。

实现：

- CoroutineComponent实现思路：
  1. 同一种锁，同一个key放入同一个队列
  2. 一个协程执行完后从自己队列中取出下一个执行

问题:

协程执行取出下一个执行时，如果消息处理不过来会产生队列内的处理逻辑的堆积。队列很多时，堆栈的层级也会很多(因为逐层调用)，导致堆栈爆掉。

改进：

取出下一个执行时，不直接执行而是放入update中执行。

问题：

协程锁死锁情况，await互相等，永远等不到

改进：

ET协程锁添加时间限制，时间到了解锁(超时机制)。