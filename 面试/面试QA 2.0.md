## 面试QA 2.0

### 1.Q：你所知道的UI框架？

A：

### 2.Q：讲述下拆装箱操作？

A：装箱就是隐式的将值类型转换成引用类型，拆箱就是显示的将引用类型转换成值类型。值类型在进行装箱后会在堆数据内新创建一个当前的值类型和对应值类型的值。

### 4.Q：单例和静态类的差别？

A：生命周期不同，单例的生命周期在于new对象时开始，而静态类的生命周期是从程序启动就开始，为整个程序的生命周期。

### 5.Q: 什么操作会导致内存泄漏？

A：内存泄漏主要体现在申请了内存却没有及时释放，当发生多次相同操作导致内存持续泄露，最后因为内存占用过大而导致游戏崩溃。

Q：怎么查找内存泄漏？

### 6.Q：常用的设计模式

A：

#### 创建型：

1.工厂模式，工厂模式生产对象我们只需要跟工厂打交道，根据需求在工厂里更换对象，工厂模式最大的优点就是解耦。主要体现在提供创建产品的接口、完整具体产品的创建、展示产品的主要特性和功能、实现抽象产品所定义的接口。

使用到工厂模式的地方，UI框架中的Window类提供的各种状态方法。2D游戏中的不同枪支不同子弹。

#### 行为型：

2.策略模式，定义一系列方法，将它们进行封装 并且使它们可相互替换。使得方法可独立使用它的客户而变化 

缺点：使用者必须知道所有策略，策略过多时类会很大。

比如子弹类，不同武器射出的子弹类型和子弹数量都不同，可以创建多个子弹策略，根据需要获取对应类型子弹。

3.观察者模式， 定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。 

当网络协议监听到指定的handler时，就是触发所有这个handler的方法

#### 结构型：

桥接模式，将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。

面试题中的鸭子有不同颜色的实现。

### 7.Q：什么是线程安全什么是线程不安全？

A：线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。

线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据

### 8Q：Dictionary和List 的区别？存储方式？

A： List是对Array的泛型封装，数据结构上为线性表。每次扩容都会扩展到原来的两倍，所以最好在初始化时就规定好容量大小。由于是基于Array实现的，所以在存储方式上存储位置也是连续的。

Dictionary是哈希表的泛型封装，存储上不是连续的，是根据Key而根据Hash算法分析产生的内存地址

### 9.Q：什么是事件系统？

A：事件系统的本质是一个事件管理中心，在事件管理中心内进行事件的注册和分发。将事件注册进事件管理中心，通过观察者模型，定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。 

### 10.Q：简单描述下ECS框架

A：面向数据，可以提高CPU的缓存命中率。Entity一个没有任何意义的实体可以是任何东西。Component存储数据的组件。System用于处理数据的系统，写逻辑的地方。优势在于可以数据和显示分离，单纯对数据做压力测试。劣势在于数据访问变复杂。

### 11.Q：ECS和OOP的区别在哪里？优势在哪里？

A： ECS的设计目的是用来把大量的模块进行集成并解耦 ,重构起来也很快。相比如OOP的思想，则是需要什么功能就添加什么组件。OOP则是对对象进行扩展，当类中的方法和数据非常判断时，维护起来会变得困难。但是个人认为最佳的情况是两者的结合，在高内聚的地方如UI框架、技能编辑需要高度依赖基类的情况下如果使用ECS组件化的方式开发会变得逻辑复杂得不偿失。

### 12.Q：ET框架？

A：ET框架采用了ECS架构（Entity-Component-System），而非传统的OOP架构，好处是开发效率非常高，并且借助于ECS的解耦功能，重构起来也很快。

但是ET的ECS也并非纯正的ECS，而是在架构学术派与实用派做了折衷，严格来说是E + S（Entity是纯数据，System是纯逻辑），那么把Component放哪了呢？在ET里Component就是Entity，Entity就是Component，但这个概念是代码层面的设计，当我们进行开发的时候，依旧要时刻谨记，Entity是一个对象，而Component是一个组件，只能依托于对象存在

### 13.Q：ref和out的区别？

A：ref和out都是按引用传递值，在声明形参和调用实参的地方都需要加上对应的关键字。

区别在于ref在传入实参时需要先初始化，在对应函数结束前可以不赋值。

out则在传入实参时可以不初始化但是函数结束前必须赋值。

### 14.Q：值类型比引用类型快，两者之间的区别

A：值类型存储在栈中。引用类型的值存储在堆中，在栈中存储引用类型的引用。当使用引用类型时，需要根据栈中存储的引用地址去寻找具体的值，所以栈的速度更快。

### 15.Q：死锁产生的原因。怎么避免

A：当线程A持有a锁，并尝试获取b锁的同时，线程B持有b锁，并尝试获取a锁。两个线程同时互相持有对方需要的锁，造成了后面所有需要这两个锁的线程堵塞就造成了死锁。

### 16.Q：进程和线程、协程的区别？

A：进程是程序执行的过程，进程需要向操作系统索要运行资源，进程是程序资源管理的最小单元。

线程是操作系统可以进行运算调度的最小单元，一个进程可以包含多个线程。

协程完全由使用者调度，拥有自己的寄存器上下文栈，一个线程内可以拥有多个协程。

## 优化篇

### 1.Q：怎么用程序区分高低端机型？

A：UnityEngine.IOS.Device.generation中就可以区分苹果机型。安卓系统则通过内存、系统、CPU来划分，可以给每个硬件进行评分按总分划分。还有一个思路就是先通过硬件比对简单区分，在进入游戏后通过帧数的高低再调整至对应的品质。

### 2.Q：图集的作用是什么？

A：减少draw call，同一个材质进行合批就可以了。避免资源浪费。

## 优化篇

### 1.Q：DrawCall是什么？比如什么操作会产生dc？如何优化？

A：CPU每次准备数据并通知给GPU的过程就称为一个DC。材质相同、相同组件位置相邻、将频繁改动的组件显示在最上层

### 2.Q：GC是什么？为什么会产生GC？怎么优化？

A：GC是CLR堆管理器上控制内存分配和释放的组件。当堆上可分配的内存不足时就会触发GC去回收未使用的对象。

会从栈引用开始跟踪，如果无引用堆里的数据，认定堆数据不再使用，开始回收内存。但是GC的操作是非常复杂的会占用很多CPU时间，对于移动设备来说频繁的垃圾回收会严重影响性能。

下面的建议可以避免GC频繁操作。

1. 减少用new创建对象的次数，在创建对象时会产生内存碎片，这样会造成碎片内存不法使用
2. 使用公用的对象（静态成员，常量），但是不能乱用，因为静态成员和常量的生命周期是整个应用程序。
3. 在频繁拼接大量字符串时StringBuilder。在使用注意，创建StringBuilder对象时要设置StringBuilder的初始大小如：StringBuilder sbHtml = new StringBuilder (size);
4. 使用object pool(对象池)
5. 在性能空闲时主动调用GC，System.GC.Collect();
6. 减少匿名函数的使用，函数引用本身是指向函数地址的指针变量，也会在堆内存中分配，用完丢弃后产生垃圾。

### 3.Q：String和StringBuilder的区别？

C#中String是引用类型。String是不可变对象，我们不能修改String的值，在对String进行连接等操作时，修改的是String指向的内存地址，若有多个值相同的String类型值，代表着都指向同一个内存地址。

StringBuidler是可变对象，可以在字符串连接的时候在对原来的字符串进行修改，但StringBuilder对象创建代价较大，所以若字符串的连接次数较少，还是使用String，这样可节省一些性能，只有有大量的或不可预知次数的字符串连接操作时才使用StringBuilder，但在连接操作小于等于100次的时候，两者几乎看不出性能差异。

StringBuilder在ToString时会重新分配一个字符串。只能减少中间状态的分配，不能避免字符串内存的分配。

### 4.Q：内存碎片的会有什么影响？

A：内存碎片一般指堆内存碎片，内存碎片会产生两个结果，游戏占用内存越来越大，GC越来越频繁。当需要申请连续堆内存时，可连续分配的堆内存不足时就会触发GC。

## 网络篇

### 1.Q：Protobuf是什么怎么解析？

A：

### 2.Q：帧同步？状态同步？状态帧同步？

A：

帧同步：按照逻辑

## 热更篇

### 1.Q：ILRuntime怎么热更？

A：通过热更DLL文件实现热更。ILRuntime借助Mono.Cecil库来读取DLL内的信息，最终得到方法的IL汇编码。在通过IL解释执行虚拟机来执行DLL中的代码。

### 2.Q：IL2CPP和Mono的区别是什么？

A：

Mono：

U3D中起初使用Mono作为虚拟机VM，C#只需要编译成一份IL，通过不同平台不同的VM解释后运行。Mono的堆内存大小在运行时只会增加不会减少，Mono上的堆内存都是程序中使用的代码段。通过GC进行内存回收，当GC后内存仍然不够则向操作系统申请扩容。

IL2CPP算法：

由于要在各个平台维护各自的Mono VM太过复杂，后续则使用IL2CPP的方案。

IL2CPP是将C#代码编译成IL语言(中间代码)后再翻译成C++来运行。翻译完后使用各平台本身拥有的C++编译器来编译。相较于Mono而言少了个运行时解析的步骤而是直接执行，因此效率更高。

在IL2CPP内也有用C++编写的VM，只是这个VM只负责内存托管，而不进行解析和运行。

## 个人篇

### 1.Q：为什么离开泡游

A：没有转正机会，未告知转正名额和转正时间。三个人转正。刚开始参加工作，适应过程稍久。

### 2.Q：在泡游主要做了什么

A：在《极品芝麻官》U3D版中，使用UGUI的不同组件实现不同的界面功能，处理UGUI界面的性能优化。UGUI性能优化主要在于取消勾选不必要的射线检测、相同组件位置相邻减少合批次数、使用TextMeshPro代替Text、文字组件尽量显示在图片上方，因为文本经常修改触发渲染。主要在于组件的命名规范，使用`puerTs`的 `JsBehaviour`关联需要设置的组件， `JsBehaviour`模拟Unity中的`MonoBehaviour`。 

用json写cache的结构，用ts编写处理cache的逻辑，用`jestjs`测试框架请求协议对逻辑进行验证

 编写Editor批量处理工具，将人物服装图片裁剪空白像素，向上或向下扩展成2次幂的宽高，2次幂方便运算在Unity中也能压缩的更小。再根据原始坐标和裁剪后的坐标生成json文件，提供给后续开发。

### 3.Q：在网趣主要做了什么

A：

1.基本上所有的UI系统都有参与。兵卡系统主要体现在升级、合成、分解，配件的穿戴、配件打造(涉及便携打造，使用递归)。协议主要使用`Protobuf`。

基于树形结构端实现的客户端红点系统，由于没有处理唯一id的功能，所以在节点内设有Root节点。Root节点管理所有依赖于这个Root节点的节点，Root节点必须为唯一的id（如道具、人物的唯一id、自己设置的id字段）。在红点System中，通过一个字典管理所有Root节点。节点内存有Root节点信息、自身信息、父级节点和所有子级节点。获得值时，向上通知。当有子节点移除时，遍历所有子节点统计红点数量。

绑定设有静态绑定和动态绑定，动态绑定通过Event触发。静态绑定现在是在节点内存放一个物体。

由于兵卡系统涉及的功能点较多、相同数据可能会有不同的存放和排列方式。创建了一个List字典的容器，一个字典管理多个List。一个字典存放所有的元素。在add的时候需要传入存储入比如哪个名字的list，需要读取时的id是什么(管理所有元素的字典的key值)，需要存放的元素。这样就保证了元素不会重复存放，又能通过list实现功能所需要的元素个数或排序。

2.编写UI里的事件系统，由于很多界面都需要监听物品变更或排行榜信息的变更，然后刷新对应的信息。创建了一个事件系统的组件基类，再根据具体需求继承基类创建成对应的如物品变更事件组件、排行榜变更事件组件。在基类里编写基础的触发虚方法。再各个需求内重写这个虚方法并执行父类的虚方法。

在UI窗体执行Onshow时，判断是否有这个组件，如果有组件则添加进事件中心内监听事件。

在事件系统内通过 事件组件的type为key进行存储，这个type通过一个switch进行子类组件的type划分。

