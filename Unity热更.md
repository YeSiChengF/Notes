# Unity热更

主要流程：

1. 设置热更配表数据结构
2. 生成热更包及热更配表放到服务器
3. 下载热更配置表读取需要热更文件
4. 下载热更文件
5. 游戏中加载热更

## Unity的跨平台性

使用CIL(通用中间语言)，CIL可以在任何支持CLI的环境中运行。 CIL基于堆栈，与CPU架构没啥关系，所以可以跨平台。 

CIL语言是运行在虚拟机中， mono运行的其实是CIL语言，CIL也并非真正的在本地运行，而是在mono运行时中运行的，运行在本地的是被编译后生成的原生代码。 

**CIL是CLI标准定义下的一种可读性较低的语言**

### CLI

CLI是CRL的子集，是.Net和CLR的灵魂，CLI为IL代码提供运行的环境，你可以将使用任何语言编写的代码通过其特定的编译器转换为 MSIL代码之后运行其上，甚至还可以自己写MSIL代码在CLI上面运行。 

### Mono提供的两种编译方式

 JIT和AOT都是将CIL进一步编译成平台的原生代码。

Ios不支持JIT的编译方式

#### JIT 即时编译

**程序执行时才编译代码，解释一条语句执行一条语句，即将一条中间的托管的语句翻译成一条机器语句，然后执行这条机器语句。 同时将编译过的代码进行缓存。**

机器既要处理代码的逻辑，同时还要进行编译的工作，所以其运行时的效率肯定是受到影响的。  因此，**Mono会有一部分代码通过AOT静态编译，以降低在程序运行时JIT动态编译在效率上的问题**。 

 不过一向严苛的IOS平台是不允许这种动态的编译方式的，这也是U3D官方无法给出热更新方案的一个原因。而Android平台恰恰相反，Dalvik虚拟机使用的就是JIT方案。 

#### AOT 提前编译或静态编译

 Mono的AOT静态编译和JIT并非对立的。**AOT同样使用了JIT来进行编译，只不过是被AOT编译的代码在程序运行之前就已经编译好了**。  当然还有一部分代码会通过JIT来进行动态编译。 

##### AOT过程

1. 收集要被编译的方法
2. 使用JIT进行编译
3. 发射（Emitting）经JIT编译过的代码和其他信息
4. 直接生成文件或者调用本地汇编器或连接器进行处理之后生成文件

### Full AOT

由于IOS平台禁止使用JIT(因为IOS封了内存或者堆的可执行权限，变相封锁了JIT的编译方式)，而Mono的AOT模式任会保留一部分代码通过JIT编译。为了解决这个问题，Mono提供了Full AOT模式。。

预先对程序集中的所有CIL代码进行AOT编译生成一个本地代码映像，然后在运行时直接加载这个映像而不再使用JIT引擎。 

## ILRunTime

ios不支持dll热更

### 基本概念

#### 域

使用热更后，在游戏中存在两个域，一个是游戏主程序，另一个是热更域

#### CLR

C#的公共运行库，公共运行环境，类似Java虚拟机。**负责资源管理(内存分配和垃圾回收)**

#### Assembly-CSharp.dll

unity编译的dll文件，非特殊目录下的脚本都存放在这，安卓可通过反射获取方法和变量

####  **hotFix.dll** 

热更工程生成的dll，主工程的代码不能热更，只有热更工程的才能热更

### 热更原理

 ILRuntime借助Mono.Cecil库来读取DLL的PE信息，以及当中类型的所有信息，最终得到方法的IL汇编码，然后通过内置的IL解译执行虚拟机来执行DLL中的代码。IL解释器代码在ILIntepreter.cs，通过Opcode来逐语句执行机器码，解释器的代码有四千多行。 

 ![img](https://img2018.cnblogs.com/blog/363476/201901/363476-20190115203700346-1102207440.png) 